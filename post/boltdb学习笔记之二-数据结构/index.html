<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><title>Boltdb学习笔记之二--数据结构 - 后端技术小屋</title><meta name=renderer content="webkit"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv=cache-control content="no-transform"><meta http-equiv=cache-control content="no-siteapp"><meta name=theme-color content="#f8f5ec"><meta name=msapplication-navbutton-color content="#f8f5ec"><meta name=apple-mobile-web-app-capable content="yes"><meta name=apple-mobile-web-app-status-bar-style content="#f8f5ec"><meta name=author content="后端侠"><meta name=description content="Boltdb学习笔记之二--数据结构"><meta name=keywords content="Hugo,theme,后端侠"><meta name=generator content="Hugo 0.62.2 with theme even"><link rel=canonical href=https://backendhouse.github.io/post/boltdb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%BA%8C-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/manifest.json><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link href=/sass/main.min.a2095472a2a8d7ddda1334cf60051cbe40ed55f2467554bb6aa4c17c9bcd27a4.css rel=stylesheet><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin=anonymous><meta property="og:title" content="Boltdb学习笔记之二--数据结构"><meta property="og:description" content="Boltdb学习笔记之二--数据结构"><meta property="og:type" content="article"><meta property="og:url" content="https://backendhouse.github.io/post/boltdb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%BA%8C-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"><meta property="article:published_time" content="2021-03-20T09:24:05+08:00"><meta property="article:modified_time" content="2021-03-20T09:24:05+08:00"><meta itemprop=name content="Boltdb学习笔记之二--数据结构"><meta itemprop=description content="Boltdb学习笔记之二--数据结构"><meta itemprop=datePublished content="2021-03-20T09:24:05+08:00"><meta itemprop=dateModified content="2021-03-20T09:24:05+08:00"><meta itemprop=wordCount content="8547"><meta itemprop=keywords content="数据库,boltdb,"><meta name=twitter:card content="summary"><meta name=twitter:title content="Boltdb学习笔记之二--数据结构"><meta name=twitter:description content="Boltdb学习笔记之二--数据结构"><!--[if lte IE 9]><script src=https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js></script><![endif]--><!--[if lt IE 9]><script src=https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js></script><script src=https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js></script><![endif]--></head><body><div id=mobile-navbar class=mobile-navbar><div class=mobile-header-logo><a href=/ class=logo>后端技术小屋</a></div><div class=mobile-navbar-icon><span></span><span></span><span></span></div></div><nav id=mobile-menu class="mobile-menu slideout-menu"><ul class=mobile-menu-list><a href=/><li class=mobile-menu-item>Home</li></a><a href=/post/><li class=mobile-menu-item>Archives</li></a><a href=/tags/><li class=mobile-menu-item>Tags</li></a><a href=/categories/><li class=mobile-menu-item>Categories</li></a></ul></nav><div class=container id=mobile-panel><header id=header class=header><div class=logo-wrapper><a href=/ class=logo>后端技术小屋</a></div><nav class=site-navbar><ul id=menu class=menu><li class=menu-item><a class=menu-item-link href=/>Home</a></li><li class=menu-item><a class=menu-item-link href=/post/>Archives</a></li><li class=menu-item><a class=menu-item-link href=/tags/>Tags</a></li><li class=menu-item><a class=menu-item-link href=/categories/>Categories</a></li></ul></nav></header><main id=main class=main><div class=content-wrapper><div id=content class=content><article class=post><header class=post-header><h1 class=post-title>Boltdb学习笔记之二--数据结构</h1><div class=post-meta><span class=post-time>2021-03-20</span><div class=post-category><a href=/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/>数据库</a></div></div></header><div class=post-toc id=post-toc><h2 class=post-toc-title>文章目录</h2><div class="post-toc-content always-active"><nav id=TableOfContents><ul><li><ul><li><a href=#node>node</a><ul><li><a href=#node的序列化-node---page>node的序列化: node -> page</a></li><li><a href=#node的反序列化page---node>node的反序列化：page -> node</a></li><li><a href=#插入数据>插入数据</a></li><li><a href=#删除数据>删除数据</a></li><li><a href=#解引用>解引用</a></li><li><a href=#释放>释放</a></li></ul></li><li><a href=#bucket>Bucket</a><ul><li><a href=#b树相关操作>B+树相关操作</a></li><li><a href=#bucket相关操作>Bucket相关操作</a></li></ul></li></ul></li></ul></nav></div></div><div class=post-content><p>在boltdb中，最核心的数据结构当属B+树了。B+树是数据库或文件系统中常见的数据结构，它的特点是能够保证数据稳定有序，因为每个叶子节点的深度都相同，因此其插入和修改操作拥有较稳定的时间复杂度。</p><p>那么boltdb中B+树的节点是如何表示的呢？答案是<code>node</code>。<code>node</code>对应<code>page</code>在内存中的数据结构，<code>node</code>序列化之后便是<code>page</code>，<code>page</code>反序列化之后是<code>node</code>。因为<code>node</code>在内存中，且<code>node</code>唯一对应B+树的一个节点</p><p>在概念上，boltdb中的一个<code>Bucket</code>唯一对应一棵B+树。如下图所示</p><p><img src=https://backendhouse.github.io/images/B+树.png alt=B+树 style=zoom:200%></p><h2 id=node>node</h2><p><code>node</code>分为两种，branch node和leaf node。</p><p>branch node如下所示，需要注意的是，boltdb中的branch node与通常的B+树略有不同，通常B+树中branch node的key数量比子节点数量多1， 而boltdb中key和子节点是一一对应的，这里应该是出于简化设计的考虑。因此在boltdb的branch node中，子节点<code>i</code>子树中的key应当介于<code>key(i)</code>和<code>key(i+1)</code>之间，左闭右开。</p><p><img src=https://backendhouse.github.io/images/leaf_and_branch.png alt=leaf_and_branch></p><p>leaf node如下所示。我们注意到叶子节点的数据除了<code>key</code>和<code>value</code>之外，还有一个<code>flags</code>，它的作用是为了区分普通数据和子<code>Bucket</code>数据。当<code>flags != 0</code>时，key为当前Bucket下的子Bucket名，value可反序列化为<code>bucket</code>结构，其中记录着子Bucket对应B+树的根节点所在的page id。稍后在<code>Bucket</code>一节中我们将会深入探讨。</p><p><img src=https://backendhouse.github.io/images/leafnode.png alt=leafnode></p><p><code>node</code>代码如下：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=color:#8be9fd;font-style:italic>type</span> nodes []<span style=color:#ff79c6>*</span>node

<span style=color:#6272a4>// inode represents an internal node inside of a node.
</span><span style=color:#6272a4></span><span style=color:#6272a4>// It can be used to point to elements in a page or point
</span><span style=color:#6272a4></span><span style=color:#6272a4>// to an element which hasn&#39;t been added to a page yet.
</span><span style=color:#6272a4></span><span style=color:#8be9fd;font-style:italic>type</span> inode <span style=color:#8be9fd;font-style:italic>struct</span> {
	flags <span style=color:#8be9fd>uint32</span>
	pgid  pgid
	key   []<span style=color:#8be9fd>byte</span>
	value []<span style=color:#8be9fd>byte</span>
}

<span style=color:#8be9fd;font-style:italic>type</span> inodes []inode

<span style=color:#6272a4>// node represents an in-memory, deserialized page.
</span><span style=color:#6272a4></span><span style=color:#8be9fd;font-style:italic>type</span> node <span style=color:#8be9fd;font-style:italic>struct</span> {
	bucket     <span style=color:#ff79c6>*</span>Bucket
	isLeaf     <span style=color:#8be9fd>bool</span>
	unbalanced <span style=color:#8be9fd>bool</span>
	spilled    <span style=color:#8be9fd>bool</span>
	key        []<span style=color:#8be9fd>byte</span>
	pgid       pgid
	parent     <span style=color:#ff79c6>*</span>node
	children   nodes
	inodes     inodes
}
</code></pre></div><p>node中的成员变量：</p><ul><li><code>bucket</code>: 当前节点所属的Bucket(直属bucket, 不包含祖先)</li><li><code>isLeaf</code>: 当前节点是否为叶子节点</li><li><code>unbalanced</code>: 表示该节点是否有可能被合并。如果从<code>node</code>中去掉了某对kv数据, 则unbalance从false变成true。合并策略见</li><li><code>spilled</code>: 表示该节点是否已经被拆分。在一个写事务中，已拆分的节点不会再被拆分。当<code>node</code>中插入数据，导致<code>node</code>中数据大小超过一定阈值时，便会触发<code>node</code>的拆分,</li><li><code>pgid</code>: 该node对应page的page id</li><li><code>parent</code>: 当前节点的父节点</li><li><code>inodes</code>: 本节点内的key/value数据对。对于叶子节点来说，key和value都存在。对于非叶子节点来说，只有key存在。</li><li><code>key</code>: <code>inodes</code>中所有key/value数据中最小的key</li><li><code>children</code>: 当前节点的所有子节点。如果当前节点是非叶子节点，则<code>len(inodes) = len(children)</code>; 如果当前节点是叶子节点，则children为空</li></ul><p><code>node</code>中的成员函数：</p><ul><li><code>minKeys</code>: node允许存在的最少key数量(leaf node情况下为1。branch node情况下为2)</li><li><code>size</code>: 返回node序列化成page之后的字节数，boltdb中以此判断当前节点是否需要分裂或合并</li><li><code>sizeLessThan</code>: 判断node序列化之后大小是否小于给定大小。出于性能考虑，实现中做了提前返回，比直接调用<code>node.size</code>并判断是否小于给定大小要快</li><li><code>pageElementSize</code>: 当前节点为leaf node时，返回<code>leafPageElementSize</code>, 即一个<code>leafPageElement</code>对象的长度；当前节点为branch node时，返回<code>branchPageElementSize</code>, 即<code>branchPageElement</code>对象的长度。</li><li><code>childAt</code>: 返回第<code>index</code>个子节点。实现上，首先从<code>inodes</code>中拿到子节点的page id, 然后从<code>bucket</code>中根据page id进行索引，最终返回子节点对应的<code>node</code>对象</li><li><code>childIndex</code>: 输入child node, 从<code>inodes</code>数组中二分查找该child node的位置。注意这里之所以能使用二分查找是因为<code>inodes</code>中所有元素都是按照key进行升序排列的</li><li><code>numChildren</code>: 返回当前节点的子节点数量</li><li><code>nextSibling</code>: 当前节点的右兄弟节点，如果没有返回nil。实现上，首先调用<code>node.childIndex</code>判断当前节点在其父节点中的位置<code>index</code>，然后返回父节点<code>index+1</code>位置的子节点</li><li><code>prevSibling</code>: 当前节点的左兄弟节点，如果没有返回nil。实现上类似<code>nextSibling</code>。</li></ul><h3 id=node的序列化-node---page>node的序列化: node -> page</h3><p><code>node.write</code>: 将node对象序列化到page中</p><p>序列化步骤：</p><ul><li>根据<code>node.isLeaf</code>设置<code>page.flags</code></li><li>检查<code>inodes</code>数组长度是否超过上限<code>0xFFFF</code>，超过则panic(因为B+树的分裂策略，这种情况不可能发生，除非有脏数据)</li><li>将<code>inodes</code>中的数据复制到<code>page.ptr</code>所指向的缓冲区中。如果node是leaf node, 则page缓冲区中写入的是<code>[]leafPageElement</code>和所有key/value对。如果node是branch node, 则page缓冲区中写入的是<code>[]branchPageElement</code>和所有的key值。</li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang>	<span style=color:#ff79c6>for</span> i, item <span style=color:#ff79c6>:=</span> <span style=color:#ff79c6>range</span> n.inodes {
		<span style=color:#50fa7b>_assert</span>(<span style=color:#8be9fd;font-style:italic>len</span>(item.key) &gt; <span style=color:#bd93f9>0</span>, <span style=color:#f1fa8c>&#34;write: zero-length inode key&#34;</span>)

		<span style=color:#6272a4>// Write the page element.
</span><span style=color:#6272a4></span>		<span style=color:#ff79c6>if</span> n.isLeaf {
			elem <span style=color:#ff79c6>:=</span> p.<span style=color:#50fa7b>leafPageElement</span>(<span style=color:#8be9fd;font-style:italic>uint16</span>(i))
			elem.pos = <span style=color:#8be9fd;font-style:italic>uint32</span>(<span style=color:#8be9fd;font-style:italic>uintptr</span>(unsafe.<span style=color:#50fa7b>Pointer</span>(<span style=color:#ff79c6>&amp;</span>b[<span style=color:#bd93f9>0</span>])) <span style=color:#ff79c6>-</span> <span style=color:#8be9fd;font-style:italic>uintptr</span>(unsafe.<span style=color:#50fa7b>Pointer</span>(elem)))
			elem.flags = item.flags
			elem.ksize = <span style=color:#8be9fd;font-style:italic>uint32</span>(<span style=color:#8be9fd;font-style:italic>len</span>(item.key))
			elem.vsize = <span style=color:#8be9fd;font-style:italic>uint32</span>(<span style=color:#8be9fd;font-style:italic>len</span>(item.value))
		} <span style=color:#ff79c6>else</span> {
			elem <span style=color:#ff79c6>:=</span> p.<span style=color:#50fa7b>branchPageElement</span>(<span style=color:#8be9fd;font-style:italic>uint16</span>(i))
			elem.pos = <span style=color:#8be9fd;font-style:italic>uint32</span>(<span style=color:#8be9fd;font-style:italic>uintptr</span>(unsafe.<span style=color:#50fa7b>Pointer</span>(<span style=color:#ff79c6>&amp;</span>b[<span style=color:#bd93f9>0</span>])) <span style=color:#ff79c6>-</span> <span style=color:#8be9fd;font-style:italic>uintptr</span>(unsafe.<span style=color:#50fa7b>Pointer</span>(elem)))
			elem.ksize = <span style=color:#8be9fd;font-style:italic>uint32</span>(<span style=color:#8be9fd;font-style:italic>len</span>(item.key))
			elem.pgid = item.pgid
			<span style=color:#50fa7b>_assert</span>(elem.pgid <span style=color:#ff79c6>!=</span> p.id, <span style=color:#f1fa8c>&#34;write: circular dependency occurred&#34;</span>)
		}

        <span style=color:#6272a4>// If the length of key+value is larger than the max allocation size
</span><span style=color:#6272a4></span>		<span style=color:#6272a4>// then we need to reallocate the byte array pointer.
</span><span style=color:#6272a4></span>		<span style=color:#6272a4>//
</span><span style=color:#6272a4></span>		<span style=color:#6272a4>// See: https://github.com/boltdb/bolt/pull/335
</span><span style=color:#6272a4></span>		klen, vlen <span style=color:#ff79c6>:=</span> <span style=color:#8be9fd;font-style:italic>len</span>(item.key), <span style=color:#8be9fd;font-style:italic>len</span>(item.value)
		<span style=color:#ff79c6>if</span> <span style=color:#8be9fd;font-style:italic>len</span>(b) &lt; klen<span style=color:#ff79c6>+</span>vlen {
			b = (<span style=color:#ff79c6>*</span>[maxAllocSize]<span style=color:#8be9fd>byte</span>)(unsafe.<span style=color:#50fa7b>Pointer</span>(<span style=color:#ff79c6>&amp;</span>b[<span style=color:#bd93f9>0</span>]))[:]
		}

		<span style=color:#6272a4>// Write data for the element to the end of the page.
</span><span style=color:#6272a4></span>		<span style=color:#8be9fd;font-style:italic>copy</span>(b[<span style=color:#bd93f9>0</span>:], item.key)
		b = b[klen:]
		<span style=color:#8be9fd;font-style:italic>copy</span>(b[<span style=color:#bd93f9>0</span>:], item.value)
		b = b[vlen:]
	}
</code></pre></div><h3 id=node的反序列化page---node>node的反序列化：page -> node</h3><p><code>node.read</code>: 从page对象初始化node，即page反序列化成node
反序列化步骤如下：</p><ul><li>复制page id到node中</li><li>根据<code>page.flags</code>确定<code>node.isLeaf</code></li><li>将page缓冲区中的数据复制到<code>node.inodes</code>中。branch page还是leaf page两种情况下数据格式略有不同。</li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=color:#6272a4>// read initializes the node from a page.
</span><span style=color:#6272a4></span><span style=color:#8be9fd;font-style:italic>func</span> (n <span style=color:#ff79c6>*</span>node) <span style=color:#50fa7b>read</span>(p <span style=color:#ff79c6>*</span>page) {
	n.pgid = p.id
	n.isLeaf = ((p.flags <span style=color:#ff79c6>&amp;</span> leafPageFlag) <span style=color:#ff79c6>!=</span> <span style=color:#bd93f9>0</span>)
	n.inodes = <span style=color:#8be9fd;font-style:italic>make</span>(inodes, <span style=color:#8be9fd;font-style:italic>int</span>(p.count))

	<span style=color:#ff79c6>for</span> i <span style=color:#ff79c6>:=</span> <span style=color:#bd93f9>0</span>; i &lt; <span style=color:#8be9fd;font-style:italic>int</span>(p.count); i<span style=color:#ff79c6>++</span> {
		inode <span style=color:#ff79c6>:=</span> <span style=color:#ff79c6>&amp;</span>n.inodes[i]
		<span style=color:#ff79c6>if</span> n.isLeaf {
			elem <span style=color:#ff79c6>:=</span> p.<span style=color:#50fa7b>leafPageElement</span>(<span style=color:#8be9fd;font-style:italic>uint16</span>(i))
			inode.flags = elem.flags
			inode.key = elem.<span style=color:#50fa7b>key</span>()
			inode.value = elem.<span style=color:#50fa7b>value</span>()
		} <span style=color:#ff79c6>else</span> {
			elem <span style=color:#ff79c6>:=</span> p.<span style=color:#50fa7b>branchPageElement</span>(<span style=color:#8be9fd;font-style:italic>uint16</span>(i))
			inode.pgid = elem.pgid
			inode.key = elem.<span style=color:#50fa7b>key</span>()
		}
		<span style=color:#50fa7b>_assert</span>(<span style=color:#8be9fd;font-style:italic>len</span>(inode.key) &gt; <span style=color:#bd93f9>0</span>, <span style=color:#f1fa8c>&#34;read: zero-length inode key&#34;</span>)
	}

	<span style=color:#6272a4>// Save first key so we can find the node in the parent when we spill.
</span><span style=color:#6272a4></span>	<span style=color:#ff79c6>if</span> <span style=color:#8be9fd;font-style:italic>len</span>(n.inodes) &gt; <span style=color:#bd93f9>0</span> {
		n.key = n.inodes[<span style=color:#bd93f9>0</span>].key
		<span style=color:#50fa7b>_assert</span>(<span style=color:#8be9fd;font-style:italic>len</span>(n.key) &gt; <span style=color:#bd93f9>0</span>, <span style=color:#f1fa8c>&#34;read: zero-length node key&#34;</span>)
	} <span style=color:#ff79c6>else</span> {
		n.key = <span style=color:#ff79c6>nil</span>
	}
}
</code></pre></div><h3 id=插入数据>插入数据</h3><p><code>node.put</code>: 向当前节点中插入<code>key/value</code>。<code>pageid</code>和<code>flags</code>这两个输入参数是相关的，当flags不为零时，表示这对kv是Bucket数据，此时<code>pageid</code>是其bucket的<code>root page</code>。当flags为零时，<code>pageid</code>没有意义，此时这对kv就是普通数据。</p><p>实现上：</p><ul><li>首先从当前节点的<code>inodes</code>二分搜索<code>key/value</code>对插入位置<code>index</code>。</li><li>如果<code>inodes</code>中存在等值的<code>key</code>, 则覆盖其<code>value</code></li><li>如果<code>inodes</code>中不存在等值<code>key</code>, 则在index位置处插入一个<code>inode</code></li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=color:#6272a4>// put inserts a key/value.
</span><span style=color:#6272a4></span><span style=color:#8be9fd;font-style:italic>func</span> (n <span style=color:#ff79c6>*</span>node) <span style=color:#50fa7b>put</span>(oldKey, newKey, value []<span style=color:#8be9fd>byte</span>, pgid pgid, flags <span style=color:#8be9fd>uint32</span>) {
    <span style=color:#ff79c6>...</span>

	<span style=color:#6272a4>// Find insertion index.
</span><span style=color:#6272a4></span>	index <span style=color:#ff79c6>:=</span> sort.<span style=color:#50fa7b>Search</span>(<span style=color:#8be9fd;font-style:italic>len</span>(n.inodes), <span style=color:#8be9fd;font-style:italic>func</span>(i <span style=color:#8be9fd>int</span>) <span style=color:#8be9fd>bool</span> { <span style=color:#ff79c6>return</span> bytes.<span style=color:#50fa7b>Compare</span>(n.inodes[i].key, oldKey) <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>-</span><span style=color:#bd93f9>1</span> })

	<span style=color:#6272a4>// Add capacity and shift nodes if we don&#39;t have an exact match and need to insert.
</span><span style=color:#6272a4></span>	exact <span style=color:#ff79c6>:=</span> (<span style=color:#8be9fd;font-style:italic>len</span>(n.inodes) &gt; <span style=color:#bd93f9>0</span> <span style=color:#ff79c6>&amp;&amp;</span> index &lt; <span style=color:#8be9fd;font-style:italic>len</span>(n.inodes) <span style=color:#ff79c6>&amp;&amp;</span> bytes.<span style=color:#50fa7b>Equal</span>(n.inodes[index].key, oldKey))
	<span style=color:#ff79c6>if</span> !exact {
		n.inodes = <span style=color:#8be9fd;font-style:italic>append</span>(n.inodes, inode{})
		<span style=color:#8be9fd;font-style:italic>copy</span>(n.inodes[index<span style=color:#ff79c6>+</span><span style=color:#bd93f9>1</span>:], n.inodes[index:])
	}

	inode <span style=color:#ff79c6>:=</span> <span style=color:#ff79c6>&amp;</span>n.inodes[index]
	inode.flags = flags
	inode.key = newKey
	inode.value = value
	inode.pgid = pgid
	<span style=color:#50fa7b>_assert</span>(<span style=color:#8be9fd;font-style:italic>len</span>(inode.key) &gt; <span style=color:#bd93f9>0</span>, <span style=color:#f1fa8c>&#34;put: zero-length inode key&#34;</span>)
}
</code></pre></div><h3 id=删除数据>删除数据</h3><p><code>node.del</code>: 从当期节点中删除一对kv数据。最后设置unbalanced为true, 表示本节点有可能触发合并</p><p>实现上：</p><ul><li>首先从<code>inodes</code>中二分查找<code>key</code>，对应位置为<code>index</code></li><li>从<code>inodes</code>中删除<code>index</code>位置的<code>inode</code>对象</li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=color:#6272a4>// del removes a key from the node.
</span><span style=color:#6272a4></span><span style=color:#8be9fd;font-style:italic>func</span> (n <span style=color:#ff79c6>*</span>node) <span style=color:#50fa7b>del</span>(key []<span style=color:#8be9fd>byte</span>) {
	<span style=color:#6272a4>// Find index of key.
</span><span style=color:#6272a4></span>	index <span style=color:#ff79c6>:=</span> sort.<span style=color:#50fa7b>Search</span>(<span style=color:#8be9fd;font-style:italic>len</span>(n.inodes), <span style=color:#8be9fd;font-style:italic>func</span>(i <span style=color:#8be9fd>int</span>) <span style=color:#8be9fd>bool</span> { <span style=color:#ff79c6>return</span> bytes.<span style=color:#50fa7b>Compare</span>(n.inodes[i].key, key) <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>-</span><span style=color:#bd93f9>1</span> })

	<span style=color:#6272a4>// Exit if the key isn&#39;t found.
</span><span style=color:#6272a4></span>	<span style=color:#ff79c6>if</span> index <span style=color:#ff79c6>&gt;=</span> <span style=color:#8be9fd;font-style:italic>len</span>(n.inodes) <span style=color:#ff79c6>||</span> !bytes.<span style=color:#50fa7b>Equal</span>(n.inodes[index].key, key) {
		<span style=color:#ff79c6>return</span>
	}

	<span style=color:#6272a4>// Delete inode from the node.
</span><span style=color:#6272a4></span>	n.inodes = <span style=color:#8be9fd;font-style:italic>append</span>(n.inodes[:index], n.inodes[index<span style=color:#ff79c6>+</span><span style=color:#bd93f9>1</span>:]<span style=color:#ff79c6>...</span>)

	<span style=color:#6272a4>// Mark the node as needing rebalancing.
</span><span style=color:#6272a4></span>	n.unbalanced = <span style=color:#ff79c6>true</span>
}
</code></pre></div><h3 id=解引用>解引用</h3><p><code>node.dereference</code>: 将所有<code>inodes</code>数据复制到<code>Heap</code>上，避免对<code>DB</code>中<code>mmap</code>缓冲区的引用，避免因为boltdb重新<code>mmap</code>造成原有<code>mmap</code>缓冲区失效。这个方法是递归的，对当前节点执行<code>dereference</code>会递归对所有子节点调用<code>dereference</code></p><h3 id=释放>释放</h3><p><code>node.free</code>: 将当前节点对应的<code>page</code>从<code>freelist</code>中释放。</p><h2 id=bucket>Bucket</h2><p>在<a href=https://mp.weixin.qq.com/s/PWczv1LuaRE7ItUqZJ9i4g>Boltdb学习笔记之〇&ndash;概述</a>中我们提到，Bucket类似于关系型数据库中的表，区别在于Bucket支持嵌套，一个Bucket中可以包含很多子Bucket。而不管是父Bucket还是子Bucket，每个Bucket都唯一对应一个B+树，B+树中存储着该Bucket的所有数据和children Bucket。因为Bucket与B+树一一对应，boltdb中所有B+树操作都能在Bucket中找到对应接口。因此接下来我们以Bucket为载体总结B+树相关操作。</p><p>以下代码定义了<code>bucket</code>和<code>Bucket</code>两种类型。在<code>bucket</code>中，<code>root</code>表示该Bucket对应的B+树的根节点page id，<code>sequence</code>是一个单调递增的id, 唯一对应一个Bucket。<code>bucket</code>可序列化为<code>[]byte</code>类型，作为leaf page中的value值。同样的，在leaf page中，如果某条<code>leafPageElement</code>数据中<code>flags != 0</code>, 我们也可读取其value值并将其反序列成<code>bucket</code>对象。</p><p><img src=https://backendhouse.github.io/images/子bucket.png alt=子bucket></p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=color:#6272a4>// bucket represents the on-file representation of a bucket.
</span><span style=color:#6272a4></span><span style=color:#6272a4>// This is stored as the &#34;value&#34; of a bucket key. If the bucket is small enough,
</span><span style=color:#6272a4></span><span style=color:#6272a4>// then its root page can be stored inline in the &#34;value&#34;, after the bucket
</span><span style=color:#6272a4></span><span style=color:#6272a4>// header. In the case of inline buckets, the &#34;root&#34; will be 0.
</span><span style=color:#6272a4></span><span style=color:#8be9fd;font-style:italic>type</span> bucket <span style=color:#8be9fd;font-style:italic>struct</span> {
    root     pgid   <span style=color:#6272a4>// page id of the bucket&#39;s root-level page
</span><span style=color:#6272a4></span>    sequence <span style=color:#8be9fd>uint64</span> <span style=color:#6272a4>// monotonically incrementing, used by NextSequence()
</span><span style=color:#6272a4></span>}
</code></pre></div><p><code>Bucket</code>由<code>bucket</code>组成，除此之外还有其他一些成员，注意这些字段仅存在于内存中，无法序列化到db文件中。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=color:#6272a4>// Bucket represents a collection of key/value pairs inside the database.
</span><span style=color:#6272a4></span><span style=color:#8be9fd;font-style:italic>type</span> Bucket <span style=color:#8be9fd;font-style:italic>struct</span> {
    <span style=color:#ff79c6>*</span>bucket
    tx       <span style=color:#ff79c6>*</span>Tx                <span style=color:#6272a4>// the associated transaction
</span><span style=color:#6272a4></span>    buckets  <span style=color:#8be9fd;font-style:italic>map</span>[<span style=color:#8be9fd>string</span>]<span style=color:#ff79c6>*</span>Bucket <span style=color:#6272a4>// subbucket cache
</span><span style=color:#6272a4></span>    page     <span style=color:#ff79c6>*</span>page              <span style=color:#6272a4>// inline page reference
</span><span style=color:#6272a4></span>    rootNode <span style=color:#ff79c6>*</span>node              <span style=color:#6272a4>// materialized node for the root page.
</span><span style=color:#6272a4></span>    nodes    <span style=color:#8be9fd;font-style:italic>map</span>[pgid]<span style=color:#ff79c6>*</span>node     <span style=color:#6272a4>// node cache
</span><span style=color:#6272a4></span>
    <span style=color:#6272a4>// Sets the threshold for filling nodes when they split. By default,
</span><span style=color:#6272a4></span>    <span style=color:#6272a4>// the bucket will fill to 50% but it can be useful to increase this
</span><span style=color:#6272a4></span>    <span style=color:#6272a4>// amount if you know that your write workloads are mostly append-only.
</span><span style=color:#6272a4></span>    <span style=color:#6272a4>//
</span><span style=color:#6272a4></span>    <span style=color:#6272a4>// This is non-persisted across transactions so it must be set in every Tx.
</span><span style=color:#6272a4></span>    FillPercent <span style=color:#8be9fd>float64</span>
}
</code></pre></div><ul><li><code>tx</code>: <code>Bucket</code>所关联的事务id</li><li><code>buckets</code>: 缓存当前<code>Bucket</code>下的子<code>Bucket</code></li><li><code>page</code>: 仅当<code>Bucket</code>为<code>inline</code>时有效，即本<code>Bucket</code>下的所有数据都可容纳于一个page中。</li><li><code>rootNode</code>: 缓存当前Bucket对应的B+树根节点</li><li><code>nodes</code>: 缓存Bucket中B+树的节点。</li><li><code>FillPercent</code>: 设置Bucket对应的B+树中的分裂阈值。默认值为50%。</li></ul><h3 id=b树相关操作>B+树相关操作</h3><h4 id=查询数据>查询数据</h4><p><code>Bucket.Get</code>会在当前<code>Bucket</code>中搜索<code>key</code>对应的value, 如果B+树中找不到key, 或者key对应的value是子Bucket数据，则返回nil值。否则返回key对应的value值。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=color:#6272a4>// Get retrieves the value for a key in the bucket.
</span><span style=color:#6272a4></span><span style=color:#6272a4>// Returns a nil value if the key does not exist or if the key is a nested bucket.
</span><span style=color:#6272a4></span><span style=color:#6272a4>// The returned value is only valid for the life of the transaction.
</span><span style=color:#6272a4></span><span style=color:#8be9fd;font-style:italic>func</span> (b <span style=color:#ff79c6>*</span>Bucket) <span style=color:#50fa7b>Get</span>(key []<span style=color:#8be9fd>byte</span>) []<span style=color:#8be9fd>byte</span> {
	k, v, flags <span style=color:#ff79c6>:=</span> b.<span style=color:#50fa7b>Cursor</span>().<span style=color:#50fa7b>seek</span>(key)

	<span style=color:#6272a4>// Return nil if this is a bucket.
</span><span style=color:#6272a4></span>	<span style=color:#ff79c6>if</span> (flags <span style=color:#ff79c6>&amp;</span> bucketLeafFlag) <span style=color:#ff79c6>!=</span> <span style=color:#bd93f9>0</span> {
		<span style=color:#ff79c6>return</span> <span style=color:#ff79c6>nil</span>
	}

	<span style=color:#6272a4>// If our target node isn&#39;t the same key as what&#39;s passed in then return nil.
</span><span style=color:#6272a4></span>	<span style=color:#ff79c6>if</span> !bytes.<span style=color:#50fa7b>Equal</span>(key, k) {
		<span style=color:#ff79c6>return</span> <span style=color:#ff79c6>nil</span>
	}
	<span style=color:#ff79c6>return</span> v
}
</code></pre></div><p>以上<code>b.Curosr().seek(key)</code>即完成了B+树中key的查找, <code>Curosr.seek</code>代码如下</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=color:#6272a4>// seek moves the cursor to a given key and returns it.
</span><span style=color:#6272a4></span><span style=color:#6272a4>// If the key does not exist then the next key is used.
</span><span style=color:#6272a4></span><span style=color:#8be9fd;font-style:italic>func</span> (c <span style=color:#ff79c6>*</span>Cursor) <span style=color:#50fa7b>seek</span>(seek []<span style=color:#8be9fd>byte</span>) (key []<span style=color:#8be9fd>byte</span>, value []<span style=color:#8be9fd>byte</span>, flags <span style=color:#8be9fd>uint32</span>) {
	<span style=color:#50fa7b>_assert</span>(c.bucket.tx.db <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>nil</span>, <span style=color:#f1fa8c>&#34;tx closed&#34;</span>)

	<span style=color:#6272a4>// Start from root page/node and traverse to correct page.
</span><span style=color:#6272a4></span>	c.stack = c.stack[:<span style=color:#bd93f9>0</span>]
	c.<span style=color:#50fa7b>search</span>(seek, c.bucket.root)
	ref <span style=color:#ff79c6>:=</span> <span style=color:#ff79c6>&amp;</span>c.stack[<span style=color:#8be9fd;font-style:italic>len</span>(c.stack)<span style=color:#ff79c6>-</span><span style=color:#bd93f9>1</span>]

	<span style=color:#6272a4>// If the cursor is pointing to the end of page/node then return nil.
</span><span style=color:#6272a4></span>	<span style=color:#ff79c6>if</span> ref.index <span style=color:#ff79c6>&gt;=</span> ref.<span style=color:#50fa7b>count</span>() {
		<span style=color:#ff79c6>return</span> <span style=color:#ff79c6>nil</span>, <span style=color:#ff79c6>nil</span>, <span style=color:#bd93f9>0</span>
	}

	<span style=color:#6272a4>// If this is a bucket then return a nil value.
</span><span style=color:#6272a4></span>	<span style=color:#ff79c6>return</span> c.<span style=color:#50fa7b>keyValue</span>()
}
</code></pre></div><p><code>Cursor.seek</code>中调用了<code>Cursor.search</code>, 该函数会从B+树根节点开始递归搜索<code>key = seek</code>的数据。如下所示，<code>Cursor.search</code>中</p><ul><li>首先根据page id获取B+树根节点对应的<code>page</code>和<code>node</code>对象(如果Bucket中已经缓存了该page, 则<code>node</code>对象有效，否则为空)</li><li>然后对page类型进行校验，必须是branch page或leaf page类型。换言之，page类型不能是meta page或freelist page</li><li>接着进行递归搜索：如果<code>n</code>有效(对应节点已被Bucket缓存)，则执行<code>Cursor.searchNode</code>；否则执行<code>Cursor.searchPage</code></li><li>递归搜索的边界条件是到达B+树叶子节点，此时调用<code>Cursor.nsearch</code>在叶子节点中查找key, 记录下第一个大于等于目标key的位置。</li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=color:#6272a4>// search recursively performs a binary search against a given page/node until it finds a given key.
</span><span style=color:#6272a4></span><span style=color:#8be9fd;font-style:italic>func</span> (c <span style=color:#ff79c6>*</span>Cursor) <span style=color:#50fa7b>search</span>(key []<span style=color:#8be9fd>byte</span>, pgid pgid) {
	p, n <span style=color:#ff79c6>:=</span> c.bucket.<span style=color:#50fa7b>pageNode</span>(pgid)
	<span style=color:#ff79c6>if</span> p <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>nil</span> <span style=color:#ff79c6>&amp;&amp;</span> (p.flags<span style=color:#ff79c6>&amp;</span>(branchPageFlag|leafPageFlag)) <span style=color:#ff79c6>==</span> <span style=color:#bd93f9>0</span> {
		<span style=color:#8be9fd;font-style:italic>panic</span>(fmt.<span style=color:#50fa7b>Sprintf</span>(<span style=color:#f1fa8c>&#34;invalid page type: %d: %x&#34;</span>, p.id, p.flags))
	}
	e <span style=color:#ff79c6>:=</span> elemRef{page: p, node: n}
	c.stack = <span style=color:#8be9fd;font-style:italic>append</span>(c.stack, e)

	<span style=color:#6272a4>// If we&#39;re on a leaf page/node then find the specific node.
</span><span style=color:#6272a4></span>	<span style=color:#ff79c6>if</span> e.<span style=color:#50fa7b>isLeaf</span>() {
		c.<span style=color:#50fa7b>nsearch</span>(key)
		<span style=color:#ff79c6>return</span>
	}

	<span style=color:#ff79c6>if</span> n <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>nil</span> {
		c.<span style=color:#50fa7b>searchNode</span>(key, n)
		<span style=color:#ff79c6>return</span>
	}
	c.<span style=color:#50fa7b>searchPage</span>(key, p)
}
</code></pre></div><p><code>Cursor.searchNode</code>里，在节点<code>n</code>的<code>inodes</code>数组中二分查找<code>key</code>，找到最后一个小于等于<code>key</code>值的<code>inode</code>的位置，接着在该位置对应的子节点中继续查找<code>key</code></p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=color:#8be9fd;font-style:italic>func</span> (c <span style=color:#ff79c6>*</span>Cursor) <span style=color:#50fa7b>searchNode</span>(key []<span style=color:#8be9fd>byte</span>, n <span style=color:#ff79c6>*</span>node) {
	<span style=color:#8be9fd;font-style:italic>var</span> exact <span style=color:#8be9fd>bool</span>
	index <span style=color:#ff79c6>:=</span> sort.<span style=color:#50fa7b>Search</span>(<span style=color:#8be9fd;font-style:italic>len</span>(n.inodes), <span style=color:#8be9fd;font-style:italic>func</span>(i <span style=color:#8be9fd>int</span>) <span style=color:#8be9fd>bool</span> {
		<span style=color:#6272a4>// TODO(benbjohnson): Optimize this range search. It&#39;s a bit hacky right now.
</span><span style=color:#6272a4></span>		<span style=color:#6272a4>// sort.Search() finds the lowest index where f() != -1 but we need the highest index.
</span><span style=color:#6272a4></span>		ret <span style=color:#ff79c6>:=</span> bytes.<span style=color:#50fa7b>Compare</span>(n.inodes[i].key, key)
		<span style=color:#ff79c6>if</span> ret <span style=color:#ff79c6>==</span> <span style=color:#bd93f9>0</span> {
			exact = <span style=color:#ff79c6>true</span>
		}
		<span style=color:#ff79c6>return</span> ret <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>-</span><span style=color:#bd93f9>1</span>
	})
	<span style=color:#ff79c6>if</span> !exact <span style=color:#ff79c6>&amp;&amp;</span> index &gt; <span style=color:#bd93f9>0</span> {
		index<span style=color:#ff79c6>--</span>
	}
	c.stack[<span style=color:#8be9fd;font-style:italic>len</span>(c.stack)<span style=color:#ff79c6>-</span><span style=color:#bd93f9>1</span>].index = index

	<span style=color:#6272a4>// Recursively search to the next page.
</span><span style=color:#6272a4></span>	c.<span style=color:#50fa7b>search</span>(key, n.inodes[index].pgid)
}
</code></pre></div><h4 id=插入数据-1>插入数据</h4><p>接口<code>Bucket.Put</code>用于在当前<code>Bucket</code>对应的B+树中插入一对key/value数据。如果key已存在，则用新value覆盖老value值，如果key不存在，则新增key/value对。</p><p>在<code>查询数据</code>这一节我们已经见到了<code>Cursor.seek</code>这个接口，它的功能从<code>Bucket</code>中搜索目标key。如果目标key存在，返回对应的key, value和flags(用于区分value是普通数据还是子Bucket数据)。如果目标key不存在，则返回大于目标key的最小key, 及其对应的value、flags</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=color:#6272a4>// Put sets the value for a key in the bucket.
</span><span style=color:#6272a4></span><span style=color:#6272a4>// If the key exist then its previous value will be overwritten.
</span><span style=color:#6272a4></span><span style=color:#6272a4>// Supplied value must remain valid for the life of the transaction.
</span><span style=color:#6272a4></span><span style=color:#6272a4>// Returns an error if the bucket was created from a read-only transaction, if the key is blank, if the key is too large, or if the value is too large.
</span><span style=color:#6272a4></span><span style=color:#8be9fd;font-style:italic>func</span> (b <span style=color:#ff79c6>*</span>Bucket) <span style=color:#50fa7b>Put</span>(key []<span style=color:#8be9fd>byte</span>, value []<span style=color:#8be9fd>byte</span>) <span style=color:#8be9fd>error</span> {
	<span style=color:#ff79c6>if</span> b.tx.db <span style=color:#ff79c6>==</span> <span style=color:#ff79c6>nil</span> {
		<span style=color:#ff79c6>return</span> ErrTxClosed
	} <span style=color:#ff79c6>else</span> <span style=color:#ff79c6>if</span> !b.<span style=color:#50fa7b>Writable</span>() {
		<span style=color:#ff79c6>return</span> ErrTxNotWritable
	} <span style=color:#ff79c6>else</span> <span style=color:#ff79c6>if</span> <span style=color:#8be9fd;font-style:italic>len</span>(key) <span style=color:#ff79c6>==</span> <span style=color:#bd93f9>0</span> {
		<span style=color:#ff79c6>return</span> ErrKeyRequired
	} <span style=color:#ff79c6>else</span> <span style=color:#ff79c6>if</span> <span style=color:#8be9fd;font-style:italic>len</span>(key) &gt; MaxKeySize {
		<span style=color:#ff79c6>return</span> ErrKeyTooLarge
	} <span style=color:#ff79c6>else</span> <span style=color:#ff79c6>if</span> <span style=color:#8be9fd;font-style:italic>int64</span>(<span style=color:#8be9fd;font-style:italic>len</span>(value)) &gt; MaxValueSize {
		<span style=color:#ff79c6>return</span> ErrValueTooLarge
	}

	<span style=color:#6272a4>// Move cursor to correct position.
</span><span style=color:#6272a4></span>	c <span style=color:#ff79c6>:=</span> b.<span style=color:#50fa7b>Cursor</span>()
	k, _, flags <span style=color:#ff79c6>:=</span> c.<span style=color:#50fa7b>seek</span>(key)

	<span style=color:#6272a4>// Return an error if there is an existing key with a bucket value.
</span><span style=color:#6272a4></span>	<span style=color:#ff79c6>if</span> bytes.<span style=color:#50fa7b>Equal</span>(key, k) <span style=color:#ff79c6>&amp;&amp;</span> (flags<span style=color:#ff79c6>&amp;</span>bucketLeafFlag) <span style=color:#ff79c6>!=</span> <span style=color:#bd93f9>0</span> {
		<span style=color:#ff79c6>return</span> ErrIncompatibleValue
	}

	<span style=color:#6272a4>// Insert into node.
</span><span style=color:#6272a4></span>	key = <span style=color:#50fa7b>cloneBytes</span>(key)
	c.<span style=color:#50fa7b>node</span>().<span style=color:#50fa7b>put</span>(key, key, value, <span style=color:#bd93f9>0</span>, <span style=color:#bd93f9>0</span>)

	<span style=color:#ff79c6>return</span> <span style=color:#ff79c6>nil</span>
}
</code></pre></div><p>所以以上代码中，当<code>Cursor.seek</code>返回之后，首先校验<code>flags</code>, 如果为子Bucket数据返回<code>ErrIncompatibleValue</code>错误。然后将key/value数据插入到<code>Cursor</code>对象<code>c</code>当前所在的节点上。</p><h4 id=删除数据-1>删除数据</h4><p><code>Bucket.Delete</code>从当前Bucket对应的B+树中删除目标key的数据。如果目标key不存在则什么也不做</p><p>实现上：</p><ul><li>校验：事务中db是否为空，当前Bucket是否可写</li><li>调用<code>Cursor.seek</code>寻找目标key在B+树上的位置。</li><li>在B+树叶子节点上删除目标key</li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=color:#6272a4>// Delete removes a key from the bucket.
</span><span style=color:#6272a4></span><span style=color:#6272a4>// If the key does not exist then nothing is done and a nil error is returned.
</span><span style=color:#6272a4></span><span style=color:#6272a4>// Returns an error if the bucket was created from a read-only transaction.
</span><span style=color:#6272a4></span><span style=color:#8be9fd;font-style:italic>func</span> (b <span style=color:#ff79c6>*</span>Bucket) <span style=color:#50fa7b>Delete</span>(key []<span style=color:#8be9fd>byte</span>) <span style=color:#8be9fd>error</span> {
	<span style=color:#ff79c6>if</span> b.tx.db <span style=color:#ff79c6>==</span> <span style=color:#ff79c6>nil</span> {
		<span style=color:#ff79c6>return</span> ErrTxClosed
	} <span style=color:#ff79c6>else</span> <span style=color:#ff79c6>if</span> !b.<span style=color:#50fa7b>Writable</span>() {
		<span style=color:#ff79c6>return</span> ErrTxNotWritable
	}

	<span style=color:#6272a4>// Move cursor to correct position.
</span><span style=color:#6272a4></span>	c <span style=color:#ff79c6>:=</span> b.<span style=color:#50fa7b>Cursor</span>()
	_, _, flags <span style=color:#ff79c6>:=</span> c.<span style=color:#50fa7b>seek</span>(key)

	<span style=color:#6272a4>// Return an error if there is already existing bucket value.
</span><span style=color:#6272a4></span>	<span style=color:#ff79c6>if</span> (flags <span style=color:#ff79c6>&amp;</span> bucketLeafFlag) <span style=color:#ff79c6>!=</span> <span style=color:#bd93f9>0</span> {
		<span style=color:#ff79c6>return</span> ErrIncompatibleValue
	}

	<span style=color:#6272a4>// Delete the node if we have a matching key.
</span><span style=color:#6272a4></span>	c.<span style=color:#50fa7b>node</span>().<span style=color:#50fa7b>del</span>(key)

	<span style=color:#ff79c6>return</span> <span style=color:#ff79c6>nil</span>
}
</code></pre></div><h4 id=节点分裂>节点分裂</h4><p>随着用户不断向<code>Bucket</code>中插入新数据，B+树的某些叶子节点可能会超过分裂阈值，从而触发分裂。</p><p><code>Bucket.spill</code>实现了当前<code>Bucket</code>对应的B+树的分裂，以及所有子<code>Bucket</code>对应的B+树的分裂(递归的)。
其实现如下：</p><ul><li>首先遍历缓存中的所有子Bucket，对于每个子Bucket<ul><li>如果子Bucket小到可以<code>inlineable</code>, 则将子Bucket对应B+树中所有page释放，并将该子Bucket序列化到value中</li><li>否则对子Bucket递归调用<code>Bucket.spill</code>，并将更新后的Bucket header序列化到value中.</li><li>在当前Bucket对应的B+树中更新子Bucket的value, key为子Bucket名</li></ul></li><li>然后对当前Bucket对应的B+树调用<code>node.spill</code>，执行节点分裂</li><li>更新当前Bucket对应的B+树的根节点(B+树节点分裂可能会生成新的根节点)</li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=color:#6272a4>// spill writes all the nodes for this bucket to dirty pages.
</span><span style=color:#6272a4></span><span style=color:#8be9fd;font-style:italic>func</span> (b <span style=color:#ff79c6>*</span>Bucket) <span style=color:#50fa7b>spill</span>() <span style=color:#8be9fd>error</span> {
	<span style=color:#6272a4>// Spill all child buckets first.
</span><span style=color:#6272a4></span>	<span style=color:#ff79c6>for</span> name, child <span style=color:#ff79c6>:=</span> <span style=color:#ff79c6>range</span> b.buckets {
		<span style=color:#6272a4>// If the child bucket is small enough and it has no child buckets then
</span><span style=color:#6272a4></span>		<span style=color:#6272a4>// write it inline into the parent bucket&#39;s page. Otherwise spill it
</span><span style=color:#6272a4></span>		<span style=color:#6272a4>// like a normal bucket and make the parent value a pointer to the page.
</span><span style=color:#6272a4></span>		<span style=color:#8be9fd;font-style:italic>var</span> value []<span style=color:#8be9fd>byte</span>
		<span style=color:#ff79c6>if</span> child.<span style=color:#50fa7b>inlineable</span>() {
			child.<span style=color:#50fa7b>free</span>()
			value = child.<span style=color:#50fa7b>write</span>()
		} <span style=color:#ff79c6>else</span> {
			<span style=color:#ff79c6>if</span> err <span style=color:#ff79c6>:=</span> child.<span style=color:#50fa7b>spill</span>(); err <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>nil</span> {
				<span style=color:#ff79c6>return</span> err
			}

			<span style=color:#6272a4>// Update the child bucket header in this bucket.
</span><span style=color:#6272a4></span>			value = <span style=color:#8be9fd;font-style:italic>make</span>([]<span style=color:#8be9fd>byte</span>, unsafe.<span style=color:#50fa7b>Sizeof</span>(bucket{}))
			<span style=color:#8be9fd;font-style:italic>var</span> bucket = (<span style=color:#ff79c6>*</span>bucket)(unsafe.<span style=color:#50fa7b>Pointer</span>(<span style=color:#ff79c6>&amp;</span>value[<span style=color:#bd93f9>0</span>]))
			<span style=color:#ff79c6>*</span>bucket = <span style=color:#ff79c6>*</span>child.bucket
		}

		<span style=color:#6272a4>// Skip writing the bucket if there are no materialized nodes.
</span><span style=color:#6272a4></span>		<span style=color:#ff79c6>if</span> child.rootNode <span style=color:#ff79c6>==</span> <span style=color:#ff79c6>nil</span> {
			<span style=color:#ff79c6>continue</span>
		}

		<span style=color:#6272a4>// Update parent node.
</span><span style=color:#6272a4></span>		<span style=color:#8be9fd;font-style:italic>var</span> c = b.<span style=color:#50fa7b>Cursor</span>()
		k, _, flags <span style=color:#ff79c6>:=</span> c.<span style=color:#50fa7b>seek</span>([]<span style=color:#8be9fd;font-style:italic>byte</span>(name))
		<span style=color:#ff79c6>if</span> !bytes.<span style=color:#50fa7b>Equal</span>([]<span style=color:#8be9fd;font-style:italic>byte</span>(name), k) {
			<span style=color:#8be9fd;font-style:italic>panic</span>(fmt.<span style=color:#50fa7b>Sprintf</span>(<span style=color:#f1fa8c>&#34;misplaced bucket header: %x -&gt; %x&#34;</span>, []<span style=color:#8be9fd;font-style:italic>byte</span>(name), k))
		}
		<span style=color:#ff79c6>if</span> flags<span style=color:#ff79c6>&amp;</span>bucketLeafFlag <span style=color:#ff79c6>==</span> <span style=color:#bd93f9>0</span> {
			<span style=color:#8be9fd;font-style:italic>panic</span>(fmt.<span style=color:#50fa7b>Sprintf</span>(<span style=color:#f1fa8c>&#34;unexpected bucket header flag: %x&#34;</span>, flags))
		}
		c.<span style=color:#50fa7b>node</span>().<span style=color:#50fa7b>put</span>([]<span style=color:#8be9fd;font-style:italic>byte</span>(name), []<span style=color:#8be9fd;font-style:italic>byte</span>(name), value, <span style=color:#bd93f9>0</span>, bucketLeafFlag)
	}

	<span style=color:#6272a4>// Ignore if there&#39;s not a materialized root node.
</span><span style=color:#6272a4></span>	<span style=color:#ff79c6>if</span> b.rootNode <span style=color:#ff79c6>==</span> <span style=color:#ff79c6>nil</span> {
		<span style=color:#ff79c6>return</span> <span style=color:#ff79c6>nil</span>
	}

	<span style=color:#6272a4>// Spill nodes.
</span><span style=color:#6272a4></span>	<span style=color:#ff79c6>if</span> err <span style=color:#ff79c6>:=</span> b.rootNode.<span style=color:#50fa7b>spill</span>(); err <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>nil</span> {
		<span style=color:#ff79c6>return</span> err
	}
	b.rootNode = b.rootNode.<span style=color:#50fa7b>root</span>()

	<span style=color:#6272a4>// Update the root node for this bucket.
</span><span style=color:#6272a4></span>	<span style=color:#ff79c6>if</span> b.rootNode.pgid <span style=color:#ff79c6>&gt;=</span> b.tx.meta.pgid {
		<span style=color:#8be9fd;font-style:italic>panic</span>(fmt.<span style=color:#50fa7b>Sprintf</span>(<span style=color:#f1fa8c>&#34;pgid (%d) above high water mark (%d)&#34;</span>, b.rootNode.pgid, b.tx.meta.pgid))
	}
	b.root = b.rootNode.pgid

	<span style=color:#ff79c6>return</span> <span style=color:#ff79c6>nil</span>
}
</code></pre></div><p>从上面的分析可以看到B+树分裂的核心逻辑其实在<code>node.spill</code>中，代码略长这里就不列出了，感兴趣的同学可查看源码。这里仅总结基本思路：</p><p>在对一个B+树节点执行分裂操作时：</p><ul><li>首先将当前节点的所有子节点按照<code>node.key</code>升序排序</li><li>然后当前节点的所有子节点递归调用<code>node.spill</code>, 执行可能触发的分裂操作</li><li>接着对当前节点调用<code>node.split</code>，返回一组分裂后的新节点, 放置于当前节点的父节点下，用于替换当前节点</li><li>最后处理边界条件：如果当前节点是B+树根节点，判断<code>node.spill</code>中是否生成了新的根节点，如果是则对新根节点执行<code>node.spill</code></li></ul><p>在<code>node.split</code>中, 将当前节点根据一定的策略分裂成一组新节点, 策略如下：</p><ol><li>如果当前节点中<code>len(n.inodes) &lt;= minKeysPerPage * 2</code>(分裂后每个page中key的数量不超过<code>minKeysPerPage</code>)，则不必分裂</li><li>如果当前节点序列化之后的大小小于<code>pageSize</code>(该节点可被一个page容纳), 则不必分裂</li><li>根据<code>fillPercent</code>计算出node分裂的大小阈值<code>threshold</code>: <code>fillPercent * pageSize</code></li><li>根据<code>threshold</code>，找到当前node的分裂点(超过阈值的临界inode的位置)</li><li>如果当前node没有parent，即自身就是B+树根节点, 则创建一个新节点作为当前节点的父节点</li><li>在当前节点分裂点处一分为二，生成两个新节点<code>left</code>和<code>right</code>, 接着对<code>right</code>节点重复执行1-6步</li></ol><p><img src=https://backendhouse.github.io/images/拆分策略.png alt=拆分策略 style=zoom:80%></p><h4 id=节点合并>节点合并</h4><p>当boltdb中的B+树不断删除数据之后，导致一些节点中的数据越来越小，此时需要对低于一定阈值的节点进行递归合并。代码中由<code>Bucket.reblance</code>实现.</p><p>在该函数中，首先对所有缓存的node调用<code>node.rebalance</code>执行合并操作，然后对所有的子Bucket递归调用<code>Bucket.rebalance</code></p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=color:#6272a4>// rebalance attempts to balance all nodes.
</span><span style=color:#6272a4></span><span style=color:#8be9fd;font-style:italic>func</span> (b <span style=color:#ff79c6>*</span>Bucket) <span style=color:#50fa7b>rebalance</span>() {
	<span style=color:#ff79c6>for</span> _, n <span style=color:#ff79c6>:=</span> <span style=color:#ff79c6>range</span> b.nodes {
		n.<span style=color:#50fa7b>rebalance</span>()
	}
	<span style=color:#ff79c6>for</span> _, child <span style=color:#ff79c6>:=</span> <span style=color:#ff79c6>range</span> b.buckets {
		child.<span style=color:#50fa7b>rebalance</span>()
	}
}
</code></pre></div><p>从上面的分析看到，节点合并的核心逻辑在<code>node.rebalance</code>中, 代码较长，这里仅总结其合并策略：</p><ol><li>如果当前节点的<code>unbalanced</code>为false, 说明该节点从在本次事务中未删除任何数据，那么无需对其合并</li><li>如果当前节点大小大于<code>pageSize</code>的1/4, 且其中key的数量大于<code>node.minKeys()</code>, 那么无需对其合并</li><li>除了1和2两种情况下，说明当前节点需要合并，合并步骤如下：</li><li>如果当前节点是B+树的根节点。按照以下两种情况细分<ul><li>如果当前节点非leaf node且子节点个数为1，将子节点的所有子节点放置于当前节点下，并去除子节点。</li><li>如果当前节点是leaf node，直接返回</li></ul></li><li>如果当前节点的子节点个数为零，则将其从父节点的<code>inodes</code>和<code>children</code>中删除，然后对父节点重新执行<code>rebalance</code></li><li>如果当前节点是其父节点的第一个子节点，则将右兄弟节点合并到当前节点中, 并对父节点执行<code>rebalance</code></li><li>如果当前节点不是其父节点的第一个子节点，则将当前节点合并到其左兄弟节点中, 并对父节点执行<code>rebalance</code></li></ol><p><img src=https://backendhouse.github.io/images/合并策略.png alt=合并策略></p><h3 id=bucket相关操作>Bucket相关操作</h3><h4 id=创建子bucket>创建子Bucket</h4><p><code>Bucket.CreateBucket</code>: 在当前Bucket下创建子Bucket.</p><ul><li>首先进行校验：db是否有效，当前Bucket是否可写，待新建Bucket的name是否为空</li><li>如果同名的子Bucket已存在，返回<code>ErrBucketExists</code>错误</li><li>如果同名的key/value数据已存在，返回<code>ErrIncompatibleValue</code>错误</li><li>在对应的B+树叶子节点中插入子Bucket数据，并返回子Bucket</li></ul><p>注意：<code>CreateBucket</code>会产生一个dirty node和一个new Bucket对象，都是在内存中，在事务提交之前不会flush到磁盘，不会影响其他只读事务。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=color:#6272a4>// CreateBucket creates a new bucket at the given key and returns the new bucket.
</span><span style=color:#6272a4></span><span style=color:#6272a4>// Returns an error if the key already exists, if the bucket name is blank, or if the bucket name is too long.
</span><span style=color:#6272a4></span><span style=color:#6272a4>// The bucket instance is only valid for the lifetime of the transaction.
</span><span style=color:#6272a4></span><span style=color:#8be9fd;font-style:italic>func</span> (b <span style=color:#ff79c6>*</span>Bucket) <span style=color:#50fa7b>CreateBucket</span>(key []<span style=color:#8be9fd>byte</span>) (<span style=color:#ff79c6>*</span>Bucket, <span style=color:#8be9fd>error</span>) {
	<span style=color:#ff79c6>if</span> b.tx.db <span style=color:#ff79c6>==</span> <span style=color:#ff79c6>nil</span> {
		<span style=color:#ff79c6>return</span> <span style=color:#ff79c6>nil</span>, ErrTxClosed
	} <span style=color:#ff79c6>else</span> <span style=color:#ff79c6>if</span> !b.tx.writable {
		<span style=color:#ff79c6>return</span> <span style=color:#ff79c6>nil</span>, ErrTxNotWritable
	} <span style=color:#ff79c6>else</span> <span style=color:#ff79c6>if</span> <span style=color:#8be9fd;font-style:italic>len</span>(key) <span style=color:#ff79c6>==</span> <span style=color:#bd93f9>0</span> {
		<span style=color:#ff79c6>return</span> <span style=color:#ff79c6>nil</span>, ErrBucketNameRequired
	}

	<span style=color:#6272a4>// Move cursor to correct position.
</span><span style=color:#6272a4></span>	c <span style=color:#ff79c6>:=</span> b.<span style=color:#50fa7b>Cursor</span>()
	k, _, flags <span style=color:#ff79c6>:=</span> c.<span style=color:#50fa7b>seek</span>(key)

	<span style=color:#6272a4>// Return an error if there is an existing key.
</span><span style=color:#6272a4></span>	<span style=color:#ff79c6>if</span> bytes.<span style=color:#50fa7b>Equal</span>(key, k) {
		<span style=color:#ff79c6>if</span> (flags <span style=color:#ff79c6>&amp;</span> bucketLeafFlag) <span style=color:#ff79c6>!=</span> <span style=color:#bd93f9>0</span> {
			<span style=color:#ff79c6>return</span> <span style=color:#ff79c6>nil</span>, ErrBucketExists
		}
		<span style=color:#ff79c6>return</span> <span style=color:#ff79c6>nil</span>, ErrIncompatibleValue
	}

	<span style=color:#6272a4>// Create empty, inline bucket.
</span><span style=color:#6272a4></span>	<span style=color:#8be9fd;font-style:italic>var</span> bucket = Bucket{
		bucket:      <span style=color:#ff79c6>&amp;</span>bucket{},
		rootNode:    <span style=color:#ff79c6>&amp;</span>node{isLeaf: <span style=color:#ff79c6>true</span>},
		FillPercent: DefaultFillPercent,
	}
	<span style=color:#8be9fd;font-style:italic>var</span> value = bucket.<span style=color:#50fa7b>write</span>()

	<span style=color:#6272a4>// Insert into node.
</span><span style=color:#6272a4></span>	key = <span style=color:#50fa7b>cloneBytes</span>(key)
	c.<span style=color:#50fa7b>node</span>().<span style=color:#50fa7b>put</span>(key, key, value, <span style=color:#bd93f9>0</span>, bucketLeafFlag)

	<span style=color:#6272a4>// Since subbuckets are not allowed on inline buckets, we need to
</span><span style=color:#6272a4></span>	<span style=color:#6272a4>// dereference the inline page, if it exists. This will cause the bucket
</span><span style=color:#6272a4></span>	<span style=color:#6272a4>// to be treated as a regular, non-inline bucket for the rest of the tx.
</span><span style=color:#6272a4></span>	b.page = <span style=color:#ff79c6>nil</span>

	<span style=color:#ff79c6>return</span> b.<span style=color:#50fa7b>Bucket</span>(key), <span style=color:#ff79c6>nil</span>
}
</code></pre></div><h4 id=获取子bucket>获取子Bucket</h4><p><code>Bucket.Bucket</code>实现了从当前Bucket中获取名为<code>name</code>的子Bucket。首先从缓存<code>Bucket.buckets</code>中查找子Bucket, 有则直接返回。否则从当前Bucket对应的B+树中查找该子Bucket, 如果存在则将子Bucket加入到缓存中，并返回；否则返回nil</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=color:#6272a4>// Bucket retrieves a nested bucket by name.
</span><span style=color:#6272a4></span><span style=color:#6272a4>// Returns nil if the bucket does not exist.
</span><span style=color:#6272a4></span><span style=color:#6272a4>// The bucket instance is only valid for the lifetime of the transaction.
</span><span style=color:#6272a4></span><span style=color:#8be9fd;font-style:italic>func</span> (b <span style=color:#ff79c6>*</span>Bucket) <span style=color:#50fa7b>Bucket</span>(name []<span style=color:#8be9fd>byte</span>) <span style=color:#ff79c6>*</span>Bucket {
	<span style=color:#ff79c6>if</span> b.buckets <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>nil</span> {
		<span style=color:#ff79c6>if</span> child <span style=color:#ff79c6>:=</span> b.buckets[<span style=color:#8be9fd;font-style:italic>string</span>(name)]; child <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>nil</span> {
			<span style=color:#ff79c6>return</span> child
		}
	}

	<span style=color:#6272a4>// Move cursor to key.
</span><span style=color:#6272a4></span>	c <span style=color:#ff79c6>:=</span> b.<span style=color:#50fa7b>Cursor</span>()
	k, v, flags <span style=color:#ff79c6>:=</span> c.<span style=color:#50fa7b>seek</span>(name)

	<span style=color:#6272a4>// Return nil if the key doesn&#39;t exist or it is not a bucket.
</span><span style=color:#6272a4></span>	<span style=color:#ff79c6>if</span> !bytes.<span style=color:#50fa7b>Equal</span>(name, k) <span style=color:#ff79c6>||</span> (flags<span style=color:#ff79c6>&amp;</span>bucketLeafFlag) <span style=color:#ff79c6>==</span> <span style=color:#bd93f9>0</span> {
		<span style=color:#ff79c6>return</span> <span style=color:#ff79c6>nil</span>
	}

	<span style=color:#6272a4>// Otherwise create a bucket and cache it.
</span><span style=color:#6272a4></span>	<span style=color:#8be9fd;font-style:italic>var</span> child = b.<span style=color:#50fa7b>openBucket</span>(v)
	<span style=color:#ff79c6>if</span> b.buckets <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>nil</span> {
		b.buckets[<span style=color:#8be9fd;font-style:italic>string</span>(name)] = child
	}

	<span style=color:#ff79c6>return</span> child
}
</code></pre></div><h4 id=删除子bucket>删除子Bucket</h4><p><code>Bucket.DeleteBucket</code>实现了在当前Bucket中删除指定<code>name</code>的子Bucket.
由于子Bucket可能还嵌套包含自己的子Bucket, 因此在从当前Bucket对应的B+树中删除该子Bucket时，还需递归调用<code>Bucket.DeleteBucket</code>将子Bucket中的子Bucket删除。</p><blockquote><p><strong>推荐阅读</strong></p></blockquote><ul><li><a href=https://mp.weixin.qq.com/s/80aFNt3STWk2xkV8qbDRqw>Boltdb学习笔记之一&ndash;存储管理</a></li><li><a href=https://mp.weixin.qq.com/s/PWczv1LuaRE7ItUqZJ9i4g>Boltdb学习笔记之〇&ndash;概述</a></li><li><a href=https://mp.weixin.qq.com/s/rI8eO1VVGmTQaMyMLOHK8g>一文读懂clickhouse集群监控</a></li><li><a href=https://mp.weixin.qq.com/s/dT3lCxkLliGgSRzSvXYxag>STL源码分析&ndash;vector</a></li><li><a href=https://mp.weixin.qq.com/s/T7i0V2hcVU3HDO7DanPuGg>zookeeper client原理总结</a></li><li><a href=https://mp.weixin.qq.com/s/DQyUboTacgB3c_9iFi-aUw>redis实现分布式锁</a></li><li><a href=https://mp.weixin.qq.com/s/sJoQAx6xk4lOlZMouayT-Q>C/C++关键字之restrict</a></li><li><a href=https://mp.weixin.qq.com/s/LBnsNeUBf34rZrewlblzcA>Python乱码九问</a></li></ul><blockquote><p>更多精彩内容，请扫码关注微信公众号：<strong>后端技术小屋</strong>。如果觉得文章对你有帮助的话，请多多分享、转发、在看。<br><img src=https://backendhouse.github.io/images/qrcode.png alt=二维码></p></blockquote></div><div class=post-copyright><p class=copyright-item><span class=item-title>文章作者</span>
<span class=item-content>后端侠</span></p><p class=copyright-item><span class=item-title>上次更新</span>
<span class=item-content>2021-03-20</span></p></div><footer class=post-footer><div class=post-tags><a href=/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/>数据库</a>
<a href=/tags/boltdb/>boltdb</a></div><nav class=post-nav><a class=prev href=/post/boltdb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%B8%80-%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86/><i class="iconfont icon-left"></i><span class="prev-text nav-default">Boltdb学习笔记之一--存储管理</span>
<span class="prev-text nav-mobile">上一篇</span></a>
<a class=next href=/post/clickhouse%E9%9B%86%E7%BE%A4zookeeper%E5%B9%B3%E6%BB%91%E6%90%AC%E8%BF%81%E5%AE%9E%E8%B7%B5/><span class="next-text nav-default">clickhouse集群zookeeper平滑搬迁实践</span>
<span class="next-text nav-mobile">下一篇</span>
<i class="iconfont icon-right"></i></a></nav></footer></article></div><script src=https://utteranc.es/client.js repo=BackendHouse/hugo-comment issue-term=pathname theme=github-light crossorigin=anonymous async></script><noscript>Please enable JavaScript to view the <a href=https://github.com/utterance>comments powered by utterances.</a></noscript></div></main><footer id=footer class=footer><div class=social-links><a href=http://github.com/%e5%90%8e%e7%ab%af%e4%be%a0 class="iconfont icon-github" title=github></a><a href=https://backendhouse.github.io/index.xml type=application/rss+xml class="iconfont icon-rss" title=rss></a></div><div class=copyright><span class=power-by>由 <a class=hexo-link href=https://gohugo.io>Hugo</a> 强力驱动</span>
<span class=division>|</span>
<span class=theme-info>主题 -
<a class=theme-link href=https://github.com/olOwOlo/hugo-theme-even>Even</a></span>
<span class=copyright-year>&copy;
2020 -
2022<span class=heart><i class="iconfont icon-heart"></i></span><span>后端侠</span></span></div></footer><div class=back-to-top id=back-to-top><i class="iconfont icon-up"></i></div></div><script src="/lib/highlight/highlight.pack.js?v=20171001"></script><script src=https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin=anonymous></script><script type=text/javascript src=/js/main.min.c12618f9a600c40bd024996677e951e64d3487006775aeb22e200c990006c5c7.js></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-SYKLLYTW9K"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments);}
gtag('js',new Date());gtag('config','G-SYKLLYTW9K');</script></body></html>