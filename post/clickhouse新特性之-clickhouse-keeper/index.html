<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><title>clickhouse新特性之————clickhouse-keeper - 后端技术小屋</title><meta name=renderer content="webkit"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv=cache-control content="no-transform"><meta http-equiv=cache-control content="no-siteapp"><meta name=theme-color content="#f8f5ec"><meta name=msapplication-navbutton-color content="#f8f5ec"><meta name=apple-mobile-web-app-capable content="yes"><meta name=apple-mobile-web-app-status-bar-style content="#f8f5ec"><meta name=author content="后端侠"><meta name=description content="[TOC] 一、介绍 clickhouse社区在21.8版本中引入了clickhouse-keeper, 用于替代zookeeper. clickhouse"><meta name=keywords content="Hugo,theme,后端侠"><meta name=generator content="Hugo 0.62.2 with theme even"><link rel=canonical href=https://backendhouse.github.io/post/clickhouse%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8B-clickhouse-keeper/><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/manifest.json><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link href=/sass/main.min.a2095472a2a8d7ddda1334cf60051cbe40ed55f2467554bb6aa4c17c9bcd27a4.css rel=stylesheet><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin=anonymous><meta property="og:title" content="clickhouse新特性之————clickhouse-keeper"><meta property="og:description" content="[TOC] 一、介绍 clickhouse社区在21.8版本中引入了clickhouse-keeper, 用于替代zookeeper. clickhouse"><meta property="og:type" content="article"><meta property="og:url" content="https://backendhouse.github.io/post/clickhouse%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8B-clickhouse-keeper/"><meta property="article:published_time" content="2022-05-16T09:30:12+08:00"><meta property="article:modified_time" content="2022-05-16T09:30:12+08:00"><meta itemprop=name content="clickhouse新特性之————clickhouse-keeper"><meta itemprop=description content="[TOC] 一、介绍 clickhouse社区在21.8版本中引入了clickhouse-keeper, 用于替代zookeeper. clickhouse"><meta itemprop=datePublished content="2022-05-16T09:30:12+08:00"><meta itemprop=dateModified content="2022-05-16T09:30:12+08:00"><meta itemprop=wordCount content="5567"><meta itemprop=keywords content="clickhouse,clickhouse-keeper,"><meta name=twitter:card content="summary"><meta name=twitter:title content="clickhouse新特性之————clickhouse-keeper"><meta name=twitter:description content="[TOC] 一、介绍 clickhouse社区在21.8版本中引入了clickhouse-keeper, 用于替代zookeeper. clickhouse"><!--[if lte IE 9]><script src=https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js></script><![endif]--><!--[if lt IE 9]><script src=https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js></script><script src=https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js></script><![endif]--></head><body><div id=mobile-navbar class=mobile-navbar><div class=mobile-header-logo><a href=/ class=logo>后端技术小屋</a></div><div class=mobile-navbar-icon><span></span><span></span><span></span></div></div><nav id=mobile-menu class="mobile-menu slideout-menu"><ul class=mobile-menu-list><a href=/><li class=mobile-menu-item>Home</li></a><a href=/post/><li class=mobile-menu-item>Archives</li></a><a href=/tags/><li class=mobile-menu-item>Tags</li></a><a href=/categories/><li class=mobile-menu-item>Categories</li></a><a href=/about/><li class=mobile-menu-item>About</li></a></ul></nav><div class=container id=mobile-panel><header id=header class=header><div class=logo-wrapper><a href=/ class=logo>后端技术小屋</a></div><nav class=site-navbar><ul id=menu class=menu><li class=menu-item><a class=menu-item-link href=/>Home</a></li><li class=menu-item><a class=menu-item-link href=/post/>Archives</a></li><li class=menu-item><a class=menu-item-link href=/tags/>Tags</a></li><li class=menu-item><a class=menu-item-link href=/categories/>Categories</a></li><li class=menu-item><a class=menu-item-link href=/about/>About</a></li></ul></nav></header><main id=main class=main><div class=content-wrapper><div id=content class=content><article class=post><header class=post-header><h1 class=post-title>clickhouse新特性之————clickhouse-keeper</h1><div class=post-meta><span class=post-time>2022-05-16</span><div class=post-category><a href=/categories/clickhouse/>clickhouse</a></div></div></header><div class=post-toc id=post-toc><h2 class=post-toc-title>文章目录</h2><div class="post-toc-content always-active"><nav id=TableOfContents><ul><li><a href=#一介绍>一、介绍</a><ul><li><a href=#11-clickhouse-keeper相比zookeeper的优点>1.1 clickhouse-keeper相比zookeeper的优点</a></li><li><a href=#12-如何部署>1.2 如何部署</a></li><li><a href=#13-如何迁移>1.3 如何迁移</a></li></ul></li><li><a href=#二源码走读>二、源码走读</a><ul><li><a href=#22-keeperdispatcher>2.2 KeeperDispatcher</a><ul><li><a href=#221-初始化>2.2.1 初始化</a></li></ul></li><li><a href=#23-keeperserver>2.3 KeeperServer</a><ul><li><a href=#231-keeperlogstore>2.3.1 KeeperLogStore</a></li><li><a href=#232-keeperstatemachine>2.3.2 KeeperStateMachine</a></li><li><a href=#233-keeperstatemanager>2.3.3 KeeperStateManager</a></li></ul></li></ul></li><li><a href=#三参考>三、参考</a></li></ul></nav></div></div><div class=post-content><p>[TOC]</p><h1 id=一介绍>一、介绍</h1><p>clickhouse社区在21.8版本中引入了clickhouse-keeper, 用于替代zookeeper. clickhouse-keeper是完全兼容zookeeper协议的分布式协调服务。目前该特性处于preproduction状态，官方还在继续完善，想用于生产环境的同学建议还是让子弹飞一会儿</p><p>clickhouse-keeper底层依赖raft协议(nuraft库)实现多节点之间状态的线性一致性。而zookeeper则使用ZAB保障一致性</p><h2 id=11-clickhouse-keeper相比zookeeper的优点>1.1 clickhouse-keeper相比zookeeper的优点</h2><p>为什么要引入clickhouse-keeper呢？主要是ck使用zookeeper有着众多痛点，</p><ul><li>使用java开发</li><li>运维不便</li><li>要求独立部署</li><li>zxid overflow问题</li><li>snapshot和log没有经过压缩</li><li>不支持读的线性一致性</li></ul><p>而keeper存在着以下优点：</p><ul><li>使用c++开发，技术栈与ck统一</li><li>即可独立部署，又可集成到ck中</li><li>没有zxid overflow问题</li><li>读性能更好，写性能相当</li><li>支持对snapshot和log的压缩和校验</li><li>支持读写的线性一致性</li></ul><h2 id=12-如何部署>1.2 如何部署</h2><p>部署clickhouse-keeper应该注意以下几点</p><ul><li>使用ssd存储append log</li><li>整个集群的节点数量不超过9</li><li>一次最多修改一个节点的config</li><li>重要参数：heart_beat_interval_ms/election_timeout_lower_bound_ms/election_timeout_upper_bound_ms/can_become_leader/priority/quorum_reads， 具体含义参考：https://clickhouse.com/docs/zh/operations/clickhouse-keeper/</li></ul><p>clickhosue-keeper有以下几种不同的部署方式</p><p>1 独立部署：类似zookeeper的部署方式，整个clickhouse集群依赖一个独立的clickhouse-keeper集群。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/zqyJwf3JkxKiaLlfCFqyFKAMuWunj6ATA3CRUtI6zeRdfskqZ0j8czFxoeNdqtb0OVZ0eMmXx5JbEQScVGpiapUQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt=图片></p><p>2 每个shard一组keeper: 此时keeper并不独立部署，而是嵌在ck进程中。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/zqyJwf3JkxKiaLlfCFqyFKAMuWunj6ATA5cRlRXA8GgiclG1mxFZH9gYjAicSzWwesibP6wlNk68wxClXaicicVpEoOg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt=图片></p><p>3 所有shard共享一组keeper: 此时keeper并不独立部署，而是嵌在ck进程中。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/zqyJwf3JkxKiaLlfCFqyFKAMuWunj6ATArPeYVPOCyVR0KJTWbbpLUXzh2ljyKVxW2NPn6DFYmcrrOoY5Yyicgmg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt=图片></p><h2 id=13-如何迁移>1.3 如何迁移</h2><p>既然clichouse-keeper优势这么明显，那么如何将zookeeper中的数据迁移到keeper中呢？官方提供了迁移工具clickhouse-keeper-converter, 它能够将zk中的数据dump成keeper能够加载的snapshot。</p><p>迁移步骤如下</p><ul><li>停止所有zk节点</li><li>找到zk leader节点</li><li>重启zk leader节点，并再次停止(这一步是为了让leader节点生成一份snapshot)</li><li>运行clickhouse-keeper-converter，生成keeper的snapshot文件</li><li>启动keeper, 使其加载上一步中的snapshot</li></ul><h1 id=二源码走读>二、源码走读</h1><p>以下仅分析keeper作为独立进程启动时的相关代码</p><p>入口：mainEntryClickHouseKeeper → Keeper::main → KeeperTCPHandler::runImpl</p><p>2.1 KeeperTCPHandler</p><p>KeeperTCPHandler是Keeper中注册的tcp请求回调。</p><ul><li><p>keeper端调用KeeperTCPHandlerFactory::createConnection创建连接</p></li><li><p>keeper端接收client端的handshake请求，格式：handshake_length(4B) | protocol_version(4B) | last_zxid_seen(8B) | timeout_ms(4B)</p></li><li><p>keeper端校验handshake成功后，并为其分配sessionid(KeeperDispatcher::getSessionID), 发送handshake响应，格式：SERVER_HANDSHAKE_LENGTH(4B) | protocol_version(4B) | session_timeout(4B) | session_id(8B) | password</p></li><li><p>keeper端将session_id 注册到KeeperDispatcher中(KeeperDispatcher::registerSession)</p></li><li><p>keeper端读取client端请求(KeeperTCPHandler::receiveRequest), 协议：length(4B) | xid (4B) | opnum(4B) | data data部分的格式由请求类型决定。详情见：ZooKeeperRequestFactory::ZooKeeperRequestFactory</p></li><li><ul><li>如果请求类型为close, 退出当前io线程</li><li>如果请求类型为heart beat, 重置session timeout 计时器</li><li>如果是其他普通类型的请求，从response队列中取出返回数据，发送给client端</li></ul></li></ul><h2 id=22-keeperdispatcher>2.2 KeeperDispatcher</h2><p>KeeperTCPHandler中依赖KeeperDispatcher实现对client端请求的处理，同时保持了keeper集群中状态的线性一致。</p><h3 id=221-初始化>2.2.1 初始化</h3><p>dispatcher启动时会在后台生成三个线程(Keeper::main -> Context::initializeKeeperDispatcher -> KeeperDispatcher::initialize):</p><ul><li>requestThread: 从request queue中取出request, 交给KeeperServer处理(KeeperServer::putRequestBatch)，得到response, 放入response queue</li><li>responseThread: 从response queue中拿到response, 调用对应session id的callback(session_to_response_callback), 将响应数据写入到tcp发送缓冲区中。</li><li>sessionCleanerTask: 从KeeperKeeper找到不活跃的session id(KeeperServer::getDeadSessions), 从内存中删除(KeeperDispatcher::finishSession)</li><li>snapshotThread: 监听snapshot queue，调用callback制作快照(KeeperStateMachine::create_snapshot)。制作快照的时机由nuraft lib决定。</li></ul><h2 id=23-keeperserver>2.3 KeeperServer</h2><p>KeeperServer基于nuraft实现了一个完整的raft实例。</p><p>KeeperServer = KeeperStateMachine + KeeperStateManager + KeeperLogStore + nuraft::raft_server + nuraft::asio_service</p><p>在nuraft库中，总共包含5个模块：</p><ul><li>raft server: 协调处理来自client和其他raft实例的请求和响应</li><li>asio layer: 负责与client/其他node的网络交互，定时器，线程池</li><li>log store: 负责raft logs的读、写、合并</li><li>state machine: raft上层的状态机，负责事务的提交和回滚，以及快照管理</li><li>state manager: 存储和加载集群配置和状态</li></ul><p>其中 log store/state machine/state manager都需要用户自行实现。</p><p>因此在clickhouse-keeper中，KeeperLogStore通过继承实现了log store模块，KeeperStateMachine实现了state machine, KeeperStateManager实现了state manager</p><p>而在test-keeper中，则通过SummingStateMachine实现了state machine, InMemoryLogStore实现了log store. 而test-keeper主要作用是在clickhouse的集成测试中替代zookeeper</p><h3 id=231-keeperlogstore>2.3.1 KeeperLogStore</h3><p>我们知道，在raft算法中, leader通过append entry到log实现leader和follower之间的replication.</p><p>clickhouse-keeper中，单个append entry的内存表示如下：</p><pre><code>struct` `ChangelogRecord``{``  ``ChangelogRecordHeader header;``  ``nuraft::ptr blob;``};` `struct` `ChangelogRecordHeader``{``  ``ChangelogVersion version = CURRENT_CHANGELOG_VERSION;``  ``uint64_t index = 0; ``/// entry log number``  ``uint64_t term = 0;``  ``nuraft::log_val_type value_type{};``  ``uint64_t blob_size = 0;``};
</code></pre><p>append entry序列化到磁盘上的格式：</p><p>checksum(8B) | version(1B) | index(8B) | term(8B) | value_type(4B) | blob_size(8B) | blob(blob_size B)</p><p>KeeperLogStore继承自nuraft::log_store</p><p>实现了append entry的：</p><ul><li>写：追加写(KeeperLogStore::append) 覆盖写(KeeperLogStore::write_at) 批量写(KeeperLogStore::apply_pack) 同步(KeeperLogState::flush)</li><li>读：随机读(entry_at) 顺序读(last_entry) 批量读(KeeperLogStore::log_entries)</li><li>合并: compact。为什么要对log进行compact呢？因为KeeperStateMachine中生成了snapshot之后, snapshot中up_to_log_idx为最大的已提交log index. 那么log store中up_to_log_idx(included)之前的entry都可以从磁盘上删除。</li></ul><h3 id=232-keeperstatemachine>2.3.2 KeeperStateMachine</h3><p>继承自nuraft::state_machine, 实现了以下接口：</p><ul><li><p>commit: 将某个log entry提交到状态机上(KeeperStorage::processRequest)</p></li><li><p>last_commit_index: 返回最近提交的log entry index</p></li><li><p>apply_snapshot: 将最新的snapshot引用到内部状态机上(KeeperSnapshotManager::deserializeSnapshotFromBuffer)</p></li><li><p>pre_commit: 无论在leader还是follower上，pre_commit都发生在append entry到log store之后，state machine commit之前。在这里为空实现</p></li><li><p>rollback: 发生在follower发现leader发送过来的append entry与自己冲突时，此时follower会先对state machine进行回滚，然后再truncate append entry直到与leader一致，最后再写入leader发送过来的append entry。这里为空实现。</p></li><li><p>last_snapshot: 获取最近的snapshot的元数据</p></li><li><p>create_snapshot: 在内存中创建snapshot, 并发送到异步队列，由KeeperDispatcher中的snapshotThread后台线程异步写入磁盘。</p></li><li><p>read_logical_snp_obj：leader发送snapshot给落后较多的follower时，会调用该接口。对于一个snapshot，可分多次调用该接口。第一次调用时，obj_id必须是零，此时data_out为空。snapshot数据在第二次调用及以后才会输出。</p></li><li><p>save_logical_snp_obj: follower接受leader发送过来的snapshot时，会调用该接口。分多次调用，同样的，第一次调用时，obj_id = 0，表示snapshot传输的开始。第二次调用时，读取snapshot数据到内存，并序列化到磁盘。详情见：https://github.com/eBay/NuRaft/blob/master/docs/snapshot_transmission.md</p></li></ul><p>KeeperStateMachine = KeeperStorage + KeeperSnapshotManager</p><p>其中KeeperStorage实现了同Zookeeper相同的内部状态, KeeperSnapshotManager实现了对多个snapshot的管理，它支持snapshot的序列化和反序列化</p><p>当clickhouse-keeper启动时，KeeperStateMachine又是如何从磁盘上初始化的呢？首先生成了KeeperSnapshotManager对象，然后从其中读取最新的snapshot, 并反序列化到KeeperStorage中。这样KeeperStateMachine就有了一个初始状态</p><h4 id=2321-keeperstorage>2.3.2.1 KeeperStorage</h4><p>所有的数据都在内存中，是类似zk的状态机。实现了类似zk的所有逻辑操作、会话管理。它的数据主要包含几部分：</p><ul><li><p>container: 使用SnapshotableHashTable来存储节点数据, 是一个可生成快照的哈希表，key为zk path, value为zk node(包含data, acl_id, children等)。SnapshotableHashTable由一个list和map组成，map的value是list iterator, list包含了多个版本的kv数据，而map反应了最新版本的kv视图</p></li><li><p>ephemerals: 用于存储每个session对应的临时节点路径</p></li><li><p>sessions_and_watchers: 用于存储每个session监听的节点路径</p></li><li><p>session_and_timeout：每个session对应的超时时间</p></li><li><p>acl_map：acl_id到acl的映射关系</p></li><li><p>watches：当前活跃监听。key: 节点路径，value: list of subscribe session</p></li><li><p>list_watches: 同上，区别在于是否监听子节点</p></li></ul><p>初始化流程：</p><ul><li>没有快照时，在container中插入root path: &ldquo;/&rdquo;</li><li>有快照时，从快照中加载 (KeeperStateMachine::init → KeeperSnapshotManager::deserializeSnapshotFromBuffer)</li></ul><p>处理请求流程：</p><ul><li>如果是close请求。从storage中清理掉所有相关session, watch，并返回response</li><li>如果是heartbeat请求。空处理</li><li>其他常规请求。检查auth(如果要求的话)，处理请求，添加watch(如果有的话)，返回</li></ul><p>退出流程：</p><ul><li>从内存中删除临时节点和watch相关数据结构</li></ul><h4 id=2322-keepersnapshotmanager>2.3.2.2 KeeperSnapshotManager</h4><p>管理所有快照文件，支持快照的序列化(到磁盘)和反序列化(到内存缓冲区)</p><p>初始化：给定snapshot目录，执行list directory得到所有snapshot开头的快照文件，加载到existing_snapshots中</p><p>序列化到磁盘：serializeSnapshotToBuffer + serializeSnapshotBufferToDisk 。输入KeeperStorage, 输出snapshot文件</p><p>反序列化到内存：deserializeSnapshotBufferFromDisk + deserializeSnapshotFromBuffer。输入snapshot文件，输出KeeperStorage</p><p>KeeperStorage序列化之后的格式: snapshot_version | snapshot_meta | session_id | acl_map | container | session_and_timeout 详情见：KeeperStorageSnapshot::serialize</p><h3 id=233-keeperstatemanager>2.3.3 KeeperStateManager</h3><p>实现了raft集群配置和状态的存储和加载。</p><p>初始化流程：</p><ul><li>加载clickhouse-keeper配置文件</li><li>从配置生成KeeperLogStore对象</li><li>从配置中确定本地raft server/port, 以及cluster_config</li><li>KeeperLogStore加载本地log文件，起点为KeeperStateMachine中的last_committed_idx</li></ul><h1 id=三参考>三、参考</h1><p>altiny ppt: <a href=https://www.slideshare.net/Altinity/clickhouse-keeper>https://www.slideshare.net/Altinity/clickhouse-keeper</a></p><p>clickhouse-keeper文档：https://clickhouse.com/docs/zh/operations/clickhouse-keeper/</p><p>nuraft文档：https://github.com/eBay/NuRaft/tree/master/docs</p></div><div class=post-copyright><p class=copyright-item><span class=item-title>文章作者</span>
<span class=item-content>后端侠</span></p><p class=copyright-item><span class=item-title>上次更新</span>
<span class=item-content>2022-05-16</span></p></div><footer class=post-footer><div class=post-tags><a href=/tags/clickhouse/>clickhouse</a>
<a href=/tags/clickhouse-keeper/>clickhouse-keeper</a></div><nav class=post-nav><a class=prev href=/post/clickhouse%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8B-mergetree%E5%90%AF%E5%8A%A8%E5%8A%A0%E9%80%9F%E4%BD%BF%E7%94%A8%E7%AF%87/><i class="iconfont icon-left"></i><span class="prev-text nav-default">clickhouse新特性之————MergeTree启动加速(使用篇)</span>
<span class="prev-text nav-mobile">上一篇</span></a>
<a class=next href=/post/clickhouse-22.3-lts-%E5%8F%91%E5%B8%83/><span class="next-text nav-default">【译】ClickHouse 22.3 LTS 发布</span>
<span class="next-text nav-mobile">下一篇</span>
<i class="iconfont icon-right"></i></a></nav></footer></article></div><script src=https://utteranc.es/client.js repo=BackendHouse/hugo-comment issue-term=pathname theme=github-light crossorigin=anonymous async></script><noscript>Please enable JavaScript to view the <a href=https://github.com/utterance>comments powered by utterances.</a></noscript></div></main><footer id=footer class=footer><div class=social-links><a href=http://github.com/%e5%90%8e%e7%ab%af%e4%be%a0 class="iconfont icon-github" title=github></a><a href=https://backendhouse.github.io/index.xml type=application/rss+xml class="iconfont icon-rss" title=rss></a></div><div class=copyright><span class=power-by>由 <a class=hexo-link href=https://gohugo.io>Hugo</a> 强力驱动</span>
<span class=division>|</span>
<span class=theme-info>主题 -
<a class=theme-link href=https://github.com/olOwOlo/hugo-theme-even>Even</a></span>
<span class=copyright-year>&copy;
2020 -
2022<span class=heart><i class="iconfont icon-heart"></i></span><span>后端侠</span></span></div></footer><div class=back-to-top id=back-to-top><i class="iconfont icon-up"></i></div></div><script src="/lib/highlight/highlight.pack.js?v=20171001"></script><script src=https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin=anonymous></script><script type=text/javascript src=/js/main.min.c12618f9a600c40bd024996677e951e64d3487006775aeb22e200c990006c5c7.js></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-SYKLLYTW9K"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments);}
gtag('js',new Date());gtag('config','G-SYKLLYTW9K');</script></body></html>