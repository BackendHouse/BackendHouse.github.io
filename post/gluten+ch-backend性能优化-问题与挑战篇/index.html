<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><title>Gluten+CH backend性能优化--问题与挑战篇 - 后端技术小屋</title><meta name=renderer content="webkit"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv=cache-control content="no-transform"><meta http-equiv=cache-control content="no-siteapp"><meta name=theme-color content="#f8f5ec"><meta name=msapplication-navbutton-color content="#f8f5ec"><meta name=apple-mobile-web-app-capable content="yes"><meta name=apple-mobile-web-app-status-bar-style content="#f8f5ec"><meta name=author content="后端侠"><meta name=description content="问题与挑战 前篇中介绍了我们在Gluen + CH backend功能支持上的工作。但是我们发现，即使所有算子或表达式都能够从vanilla spark offl"><meta name=keywords content="Hugo,theme,后端侠"><meta name=generator content="Hugo 0.62.2 with theme even"><link rel=canonical href=https://backendhouse.github.io/post/gluten+ch-backend%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E9%97%AE%E9%A2%98%E4%B8%8E%E6%8C%91%E6%88%98%E7%AF%87/><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/manifest.json><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link href=/sass/main.min.a2095472a2a8d7ddda1334cf60051cbe40ed55f2467554bb6aa4c17c9bcd27a4.css rel=stylesheet><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin=anonymous><meta property="og:title" content="Gluten+CH backend性能优化--问题与挑战篇"><meta property="og:description" content="问题与挑战 前篇中介绍了我们在Gluen + CH backend功能支持上的工作。但是我们发现，即使所有算子或表达式都能够从vanilla spark offl"><meta property="og:type" content="article"><meta property="og:url" content="https://backendhouse.github.io/post/gluten+ch-backend%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E9%97%AE%E9%A2%98%E4%B8%8E%E6%8C%91%E6%88%98%E7%AF%87/"><meta property="article:published_time" content="2025-05-23T18:24:05+08:00"><meta property="article:modified_time" content="2025-05-23T18:24:05+08:00"><meta itemprop=name content="Gluten+CH backend性能优化--问题与挑战篇"><meta itemprop=description content="问题与挑战 前篇中介绍了我们在Gluen + CH backend功能支持上的工作。但是我们发现，即使所有算子或表达式都能够从vanilla spark offl"><meta itemprop=datePublished content="2025-05-23T18:24:05+08:00"><meta itemprop=dateModified content="2025-05-23T18:24:05+08:00"><meta itemprop=wordCount content="5175"><meta itemprop=keywords content="gluten,clickhouse,性能优化,"><meta name=twitter:card content="summary"><meta name=twitter:title content="Gluten+CH backend性能优化--问题与挑战篇"><meta name=twitter:description content="问题与挑战 前篇中介绍了我们在Gluen + CH backend功能支持上的工作。但是我们发现，即使所有算子或表达式都能够从vanilla spark offl"><!--[if lte IE 9]><script src=https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js></script><![endif]--><!--[if lt IE 9]><script src=https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js></script><script src=https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js></script><![endif]--></head><body><div id=mobile-navbar class=mobile-navbar><div class=mobile-header-logo><a href=/ class=logo>后端技术小屋</a></div><div class=mobile-navbar-icon><span></span><span></span><span></span></div></div><nav id=mobile-menu class="mobile-menu slideout-menu"><ul class=mobile-menu-list><a href=/><li class=mobile-menu-item>Home</li></a><a href=/post/><li class=mobile-menu-item>Archives</li></a><a href=/tags/><li class=mobile-menu-item>Tags</li></a><a href=/categories/><li class=mobile-menu-item>Categories</li></a><a href=/about/><li class=mobile-menu-item>About</li></a></ul></nav><div class=container id=mobile-panel><header id=header class=header><div class=logo-wrapper><a href=/ class=logo>后端技术小屋</a></div><nav class=site-navbar><ul id=menu class=menu><li class=menu-item><a class=menu-item-link href=/>Home</a></li><li class=menu-item><a class=menu-item-link href=/post/>Archives</a></li><li class=menu-item><a class=menu-item-link href=/tags/>Tags</a></li><li class=menu-item><a class=menu-item-link href=/categories/>Categories</a></li><li class=menu-item><a class=menu-item-link href=/about/>About</a></li></ul></nav></header><main id=main class=main><div class=content-wrapper><div id=content class=content><article class=post><header class=post-header><h1 class=post-title>Gluten+CH backend性能优化--问题与挑战篇</h1><div class=post-meta><span class=post-time>2025-05-23</span><div class=post-category><a href=/categories/gluten/>gluten</a></div></div></header><div class=post-toc id=post-toc><h2 class=post-toc-title>文章目录</h2><div class="post-toc-content always-active"><nav id=TableOfContents><ul><li><a href=#问题与挑战>问题与挑战</a><ul><li><a href=#同步远程io>同步远程IO</a></li><li><a href=#计划优化不充分>计划优化不充分</a></li><li><a href=#cpu执行效率不高>CPU执行效率不高</a><ul><li><a href=#branch-miss>branch-miss</a></li><li><a href=#cache-miss>cache-miss</a></li><li><a href=#indirect-call>indirect call</a></li><li><a href=#page-fault>page fault</a></li><li><a href=#自动向量化失败>自动向量化失败</a></li></ul></li><li><a href=#其他>其他</a></li><li><a href=#总结>总结</a></li><li><a href=#参考>参考</a></li></ul></li></ul></nav></div></div><div class=post-content><h1 id=问题与挑战>问题与挑战</h1><p><a href=https://backendhouse.github.io/post/gluten+ch-backend%E4%BB%8B%E7%BB%8D/>前篇</a>中介绍了我们在Gluen + CH backend功能支持上的工作。但是我们发现，即使所有算子或表达式都能够从vanilla spark offload到Gluten中执行，在少数场景下性能还不是很可观，表现为和vanilla spark持平甚至低于它。因此，在功能完备的前提下，我们要对Gluten的性能进行专项优化。根据我们对生产环境的观察，Gluten的性能瓶颈主要在于CPU、Memory和网络IO。以下将展开讲讲导致这些瓶颈的原因。</p><h2 id=同步远程io>同步远程IO</h2><p>IO方面的问题主要体现在</p><ol><li>离线ETL场景中，IO请求次数和数据量都很大</li></ol><p>出于成本考虑，我们的基础设施层自建机房和自运维服务器，使用Apache Hive/HDFS + Yarn + Spark架构来支持业务进行批量数据分析和处理。我们在Spark中的工作负载主要是离线ETL任务，其中的IO占比显著比OLAP要高。每个spark executor中的scan算子都会访问HDFS集群中的Hive表。这其中涉及到大量的IO请求。</p><p>我们知道，在Hive表写文件时一般会设置对文件的压缩, 例如ORC格式中会按照一个固定的阈值(compression block size)对列式数据进行压缩，Parquet格式中会在Page数据从内存写入到磁盘前对其进行压缩, Page默认大小1MB，而Text格式则会对文件整体进行压缩。因此IO读取的数据量越大，解压缩的代价也就越大。因此影响scan算子性能的不止是IO, 还有decompress。</p><ol start=2><li>同步IO模型阻塞CPU计算
CH backend中使用libhdfs3库访问HDFS集群，libhdfs3中的hdfsRead是同步阻塞调用，每次读取的延迟在毫秒量级。</li></ol><p>HDFS文件大概有三种格式，他们的读取模式如下：</p><ul><li>ORC/Parquet: 列式存储，需要多次小范围随机读(如读取Footer、 Index等元数据)</li></ul><p><img src=https://backendhouse.github.io/images/Gluten+CH%20backend%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96--%E5%B7%A5%E5%85%B7%E7%AF%87/image-1.png alt=ORC文件结构></p><ul><li>Text：行式存储，基本是顺序读，当file split很大时读取频繁</li></ul><p>CH的同步模型决定了，在读取HDF文件时大量的读操作都会阻塞工作线程，造成CPU空闲。</p><ol start=3><li>压缩文件(bzip2)无法分区读</li></ol><p>Spark为了提升task的并行度，会将HDFS file拆分成多个file split，每个任务读取一个file split，从而. 对于ORC来说, 一个file split可能对应着一个或多个Stripe, 对Parquet来说，一个file split对应一个或多个Row Group。对Text格式来说，一个file split对应着一个文件段。</p><p><img src=https://backendhouse.github.io/images/Gluten+CH%20backend%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96--%E5%B7%A5%E5%85%B7%E7%AF%87/image.png alt="alt text"></p><p>bzip2是一种常用的文件压缩格式，它是vanilla spark中唯一支持分区读的压缩格式。但是在Gluten中尚未实现对bzip2的分区读，这就导致了在Gluten中一个分区必须读取至少一个bzip2文件并对其进行解压，当bzip2文件非常大(GB量级)时，scan算子成为拖慢整个查询的瓶颈。</p><h2 id=计划优化不充分>计划优化不充分</h2><p>Vanilla Spark中其实已经有很多执行计划的优化规则，如合并project、谓词下推，嵌套列裁剪等。在Gluten中，虽然也能利用这些优化规则，但是在某些场景下最终下发给CH Backend的计划未必是最优的。原因主要有以下几点</p><ol><li><p>CH虽然也自带很多优化规则，但是大部分对Gluten不生效
CH自带的优化规则分为两大类，基于逻辑计划(IQueryTreeNode)优化(IQueryTreePass)，和基于物理计划(IQueryPlanStep)优化(QueryPlanOptimizations)。由于Gluten是直接将substrait plan转成CH的物理计划，因此无法利用CH自带的基于逻辑计划的优化规则。另外CH自带的基于物理计划的优化规则中，有很多是针对MergeTree的，对Gluten没有意义。</p></li><li><p>Spark中表达式层面的优化是在jvm执行阶段完成的，对Gluten没意义。</p></li></ol><p>例如，spark查询中的CSE(Common Subexpression Elimination)优化是在物理执行阶段的Whole-Stage Codegen中进行的，这个阶段的优化当然不会对Gluten生效。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=color:#ff79c6>explain</span> formatted <span style=color:#ff79c6>select</span> hash(id), hash(id)<span style=color:#ff79c6>+</span><span style=color:#bd93f9>1</span>, hash(id)<span style=color:#ff79c6>-</span><span style=color:#bd93f9>1</span> <span style=color:#ff79c6>from</span> range(<span style=color:#bd93f9>10</span>)
<span style=color:#ff79c6>+</span><span style=color:#6272a4>----------------------------------------------------+
</span><span style=color:#6272a4></span><span style=color:#ff79c6>|</span>                        plan                        <span style=color:#ff79c6>|</span>
<span style=color:#ff79c6>+</span><span style=color:#6272a4>----------------------------------------------------+
</span><span style=color:#6272a4></span><span style=color:#ff79c6>|</span> <span style=color:#ff79c6>=</span><span style=color:#ff79c6>=</span> Physical Plan <span style=color:#ff79c6>=</span><span style=color:#ff79c6>=</span>
CHNativeColumnarToRow (<span style=color:#bd93f9>4</span>)
<span style=color:#ff79c6>+</span><span style=color:#ff79c6>-</span> <span style=color:#ff79c6>^</span> ProjectExecTransformer (<span style=color:#bd93f9>2</span>)
   <span style=color:#ff79c6>+</span><span style=color:#ff79c6>-</span> <span style=color:#ff79c6>^</span> CHRangeExecTransformer (<span style=color:#bd93f9>1</span>)


(<span style=color:#bd93f9>1</span>) CHRangeExecTransformer
<span style=color:#ff79c6>Output</span> [<span style=color:#bd93f9>1</span>]: [id<span style=color:#ff79c6>#</span><span style=color:#bd93f9>5</span>L]
Arguments: <span style=color:#bd93f9>0</span>, <span style=color:#bd93f9>10</span>, <span style=color:#bd93f9>1</span>, <span style=color:#bd93f9>1</span>, <span style=color:#bd93f9>10</span>, [id<span style=color:#ff79c6>#</span><span style=color:#bd93f9>5</span>L]

(<span style=color:#bd93f9>2</span>) ProjectExecTransformer
<span style=color:#ff79c6>Output</span> [<span style=color:#bd93f9>3</span>]: [hash(id<span style=color:#ff79c6>#</span><span style=color:#bd93f9>5</span>L, <span style=color:#bd93f9>42</span>) <span style=color:#ff79c6>AS</span> hash(id)<span style=color:#ff79c6>#</span><span style=color:#bd93f9>6</span>, (hash(id<span style=color:#ff79c6>#</span><span style=color:#bd93f9>5</span>L, <span style=color:#bd93f9>42</span>) <span style=color:#ff79c6>+</span> <span style=color:#bd93f9>1</span>) <span style=color:#ff79c6>AS</span> (hash(id) <span style=color:#ff79c6>+</span> <span style=color:#bd93f9>1</span>)<span style=color:#ff79c6>#</span><span style=color:#bd93f9>7</span>, (hash(id<span style=color:#ff79c6>#</span><span style=color:#bd93f9>5</span>L, <span style=color:#bd93f9>42</span>) <span style=color:#ff79c6>-</span> <span style=color:#bd93f9>1</span>) <span style=color:#ff79c6>AS</span> (hash(id) <span style=color:#ff79c6>-</span> <span style=color:#bd93f9>1</span>)<span style=color:#ff79c6>#</span><span style=color:#bd93f9>8</span>]
<span style=color:#ff79c6>Input</span> [<span style=color:#bd93f9>1</span>]: [id<span style=color:#ff79c6>#</span><span style=color:#bd93f9>5</span>L]

(<span style=color:#bd93f9>3</span>) WholeStageCodegenTransformer (<span style=color:#bd93f9>1</span>)
<span style=color:#ff79c6>Input</span> [<span style=color:#bd93f9>3</span>]: [hash(id)<span style=color:#ff79c6>#</span><span style=color:#bd93f9>6</span>, (hash(id) <span style=color:#ff79c6>+</span> <span style=color:#bd93f9>1</span>)<span style=color:#ff79c6>#</span><span style=color:#bd93f9>7</span>, (hash(id) <span style=color:#ff79c6>-</span> <span style=color:#bd93f9>1</span>)<span style=color:#ff79c6>#</span><span style=color:#bd93f9>8</span>]
Arguments: <span style=color:#ff79c6>false</span>

(<span style=color:#bd93f9>4</span>) CHNativeColumnarToRow
<span style=color:#ff79c6>Input</span> [<span style=color:#bd93f9>3</span>]: [hash(id)<span style=color:#ff79c6>#</span><span style=color:#bd93f9>6</span>, (hash(id) <span style=color:#ff79c6>+</span> <span style=color:#bd93f9>1</span>)<span style=color:#ff79c6>#</span><span style=color:#bd93f9>7</span>, (hash(id) <span style=color:#ff79c6>-</span> <span style=color:#bd93f9>1</span>)<span style=color:#ff79c6>#</span><span style=color:#bd93f9>8</span>]
</code></pre></div><p>可以看到，虽然<code>hash(id)</code>是重复子表达式，它在<code>ProjectExecTransformer</code>算子中被计算了3次，而实际上只需要计算一次。</p><ol start=3><li>生产环境有些corner case, 未必能被Spark优化规则覆盖。</li></ol><p>以下是生产环境的简化case, 首先在本地创建orc表，并查看查询计划：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=color:#ff79c6>CREATE</span> <span style=color:#ff79c6>TABLE</span> aj (
  country STRING,
  event STRUCT <span style=color:#ff79c6>&lt;</span> time: <span style=color:#8be9fd;font-style:italic>BIGINT</span>, lng: <span style=color:#8be9fd;font-style:italic>BIGINT</span>, lat: <span style=color:#8be9fd;font-style:italic>BIGINT</span>, net: STRING, log_extra: <span style=color:#ff79c6>MAP</span> <span style=color:#ff79c6>&lt;</span> STRING, STRING <span style=color:#ff79c6>&gt;</span>, event_id: STRING, event_info: <span style=color:#ff79c6>MAP</span> <span style=color:#ff79c6>&lt;</span> STRING, STRING <span style=color:#ff79c6>&gt;</span> <span style=color:#ff79c6>&gt;</span>
)
<span style=color:#ff79c6>USING</span>
  orc;

<span style=color:#ff79c6>explain</span> formatted
<span style=color:#ff79c6>SELECT</span>
  <span style=color:#ff79c6>*</span>
<span style=color:#ff79c6>FROM</span>
  (
    <span style=color:#ff79c6>SELECT</span>
      game_name,
      <span style=color:#ff79c6>CASE</span>
        <span style=color:#ff79c6>WHEN</span> event.event_info [ <span style=color:#f1fa8c>&#39;</span><span style=color:#f1fa8c>tab_type</span><span style=color:#f1fa8c>&#39;</span> ] <span style=color:#ff79c6>IN</span> (<span style=color:#bd93f9>5</span>) <span style=color:#ff79c6>THEN</span> <span style=color:#f1fa8c>&#39;</span><span style=color:#f1fa8c>1</span><span style=color:#f1fa8c>&#39;</span>
        <span style=color:#ff79c6>ELSE</span> <span style=color:#f1fa8c>&#39;</span><span style=color:#f1fa8c>0</span><span style=color:#f1fa8c>&#39;</span>
      <span style=color:#ff79c6>END</span> <span style=color:#ff79c6>AS</span> entrance
    <span style=color:#ff79c6>FROM</span>
      aj
      <span style=color:#ff79c6>LATERAL</span> <span style=color:#ff79c6>VIEW</span> explode(split(country, <span style=color:#f1fa8c>&#39;</span><span style=color:#f1fa8c>, </span><span style=color:#f1fa8c>&#39;</span>)) game_name <span style=color:#ff79c6>AS</span> game_name
    <span style=color:#ff79c6>WHERE</span>
      event.event_info [ <span style=color:#f1fa8c>&#39;</span><span style=color:#f1fa8c>action</span><span style=color:#f1fa8c>&#39;</span> ] <span style=color:#ff79c6>IN</span> (<span style=color:#bd93f9>13</span>)
  )
<span style=color:#ff79c6>WHERE</span>
  game_name <span style=color:#ff79c6>=</span> <span style=color:#f1fa8c>&#39;</span><span style=color:#f1fa8c>xxx</span><span style=color:#f1fa8c>&#39;</span>;
</code></pre></div><p>我们可以看到，event是一个struct字段，查询中只依赖了event.event_info这个子字段，但是其查询计划中scan算子却读取了其他所有子字段，即Spark自带的嵌套列裁剪规则并没有覆盖上面的case。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#ff79c6>(</span>1<span style=color:#ff79c6>)</span> ScanTransformer orc default.aj
Output <span style=color:#ff79c6>[</span>2<span style=color:#ff79c6>]</span>: <span style=color:#ff79c6>[</span>country#41, event#42<span style=color:#ff79c6>]</span>
Batched: <span style=color:#8be9fd;font-style:italic>true</span>
Location: InMemoryFileIndex <span style=color:#ff79c6>[</span>file:/data1/liyang/cppproject/spark/spark-3.3.2-bin-hadoop3/spark-warehouse/aj<span style=color:#ff79c6>]</span>
PushedFilters: <span style=color:#ff79c6>[</span>IsNotNull<span style=color:#ff79c6>(</span>event.event_info<span style=color:#ff79c6>)</span><span style=color:#ff79c6>]</span>
ReadSchema: struct&lt;country:string,event:struct&lt;time:bigint,lng:bigint,lat:bigint,net:string,log_extra:map&lt;string,string&gt;,event_id:string,event_info:map&lt;string,string&gt;&gt;&gt;
</code></pre></div><p>读取了不必要的子字段会导致</p><ul><li>更多的IO请求次数和数据量</li><li>解压缩消耗更多CPU</li><li>计算消耗更多CPU和Memory</li></ul><ol start=4><li>Spark和CH实现的差异性导致经过Spark规则优化的计划在CH中仍有进一步优化的空间。</li></ol><p>如：Spark中and或or等逻辑计算只接受两个参数，但是在CH中，他们可接受多个参数。考虑查询中过滤条件有and或or的嵌套情况，如<code>and(and(and(cond1, cond2), cond3), cond4)</code>, 在CH backend中有优化成<code>and(cond1, cond2, cond3, cond3)</code>。在CH中，相比前者，后者的优势在于能减少中间结果列的物化代价，从而提升表达式的计算性能。</p><h2 id=cpu执行效率不高>CPU执行效率不高</h2><p>我们知道，Gluten项目的初心就是利用Native Engine的向量化能力，充分压榨CPU，从而获得比基于JVM的查询引擎更好的性能。因此提高CPU执行效率，对提升Gluten的性能至关重要。</p><p>在Native Engine中，影响CPU执行效率的因素有</p><ol><li>低效的算法或库实现</li></ol><p>在native engine中，即便硬件资源充足，低效的算法或库实现仍然可能成为系统的性能瓶颈。</p><p>例1: CH早期的hash join算子不支持并行执行，hash join算子的build side和probe side并行度必须为1，这使得大数据量下join成为性能瓶颈。后来我们实现了<a href=https://github.com/ClickHouse/ClickHouse/pull/36415>parallel hash join算法</a>，build side可并行hash table, probe side也是并行的，每个线程内对输入Block行scatter，得到多个分区的Block，再为每个分区的Block执行probe, 最终将每个分区的join结果合并。后来社区基于parallel hash join进一步进行了<a href=https://github.com/ClickHouse/ClickHouse/pull/73089>优化</a>, 优化后build side每个线程并行构建two level hash table的的部分bucket, 在build结束之后将每个线程构建的结果进行零代价的合并，得到全局的two level hash table。得益于此，probe side无需进行scatter, 这避免了分区和合并的巨大开销。</p><p>例2: CH早期的orc reader调用的arrow C++库来读取orc文件，但是整个过程会对列式数据做几层转换：首先将orc列式结构转化为arrow中的列式结构，再将arrow的列式结构转化为CH的列式结构。实际上，如果我们启用arrow库，<a href=https://github.com/ClickHouse/ClickHouse/pull/53324>直接使用orc库</a>，中间这一层转换开销就可以去掉。</p><img src="https://backendhouse.github.io/images/Gluten+CH backend性能优化--工具篇/image-3.png" alt="alt text" width=1000><ol start=2><li>低效的循环
Native Engine通过循环处理列式数据的每一行。例如</li></ol><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#ff79c6>for</span> (size_t i <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>0</span>; i <span style=color:#ff79c6>&lt;</span> rows; <span style=color:#ff79c6>+</span><span style=color:#ff79c6>+</span>i)
{
    <span style=color:#6272a4>/// Process inputs
</span><span style=color:#6272a4></span>    ...

    <span style=color:#6272a4>/// Assign output
</span><span style=color:#6272a4></span>    result[i] <span style=color:#ff79c6>=</span> ...
}
</code></pre></div><p><img src=https://backendhouse.github.io/images/Gluten+CH%20backend%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96--%E5%B7%A5%E5%85%B7%E7%AF%87/image-2.png alt="alt text"></p><p>Gluten中默认一个列块的最大行数是8192, 在这个量级的循环下，循环体内任何一个微小的性能瑕疵都可能会被放大，进而影响整体的执行效率。这些因素包括</p><h3 id=branch-miss>branch-miss</h3><p>现代CPU采用流水线并行+分支预测的方式执行指令，分支预测失败会导致流水线清空，产生十几个周期的性能惩罚。而且条件分支还会阻碍编译器的自动向量化优化，无法使用SIMD指令来加速循环。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp>        <span style=color:#ff79c6>for</span> (size_t i <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>0</span>; i <span style=color:#ff79c6>&lt;</span> src_vec<span style=color:#ff79c6>-</span><span style=color:#ff79c6>&gt;</span>size(); <span style=color:#ff79c6>+</span><span style=color:#ff79c6>+</span>i)
        {
            F element <span style=color:#ff79c6>=</span> src_vec<span style=color:#ff79c6>-</span><span style=color:#ff79c6>&gt;</span>getElement(i);
            <span style=color:#ff79c6>if</span> (isNaN(element) <span style=color:#ff79c6>|</span><span style=color:#ff79c6>|</span> <span style=color:#ff79c6>!</span>isFinite(element))
                null_map_data[i] <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>1</span>;
            <span style=color:#ff79c6>else</span> <span style=color:#50fa7b>if</span> (element <span style=color:#ff79c6>&gt;</span> int_max_value)
                data[i] <span style=color:#ff79c6>=</span> int_max_value;
            <span style=color:#ff79c6>else</span> <span style=color:#50fa7b>if</span> (element <span style=color:#ff79c6>&lt;</span> int_min_value)
                data[i] <span style=color:#ff79c6>=</span> int_min_value;
            <span style=color:#ff79c6>else</span>
                data[i] <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>static_cast</span><span style=color:#ff79c6>&lt;</span>T<span style=color:#ff79c6>&gt;</span>(element);
        }
</code></pre></div><p>以上是gluten中一段优化前的代码，循环体内引入了四个分支，严重影响了循环体的性能。经过<a href=https://github.com/apache/incubator-gluten/pull/8708>优化消除分支后</a>，性能是优化前的2.67</p><h3 id=cache-miss>cache-miss</h3><p>CPU采用多级缓存（L1/L2/L3）以缓解CPU与主存之间的速度鸿沟。当CPU请求的数据不在当前缓存层级时即发生缓存未命中，需向下一级存储发起访问，这种情况成为cache-miss。当数据不在L1/L2/L3 cache中时，需要向内存发起访问，此为LLC-miss。</p><p>cache-miss是有代价的，访问L1 cache只需要几个CPU cycles, 访问L2 cache需要十几个cycles, 访问L3 cache需要几十个cycles, 而访问内存需要上百个cycles。因此cache-miss尤其是LLC-miss会造成严重的性能下降。
cache miss的情况容易发生在aggregate或join算子的hash table的随机访问中。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#6272a4>// 行优先遍历（缓存友好）
</span><span style=color:#6272a4></span><span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>0</span>; i <span style=color:#ff79c6>&lt;</span> ROWS; i<span style=color:#ff79c6>+</span><span style=color:#ff79c6>+</span>) {
    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> j <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>0</span>; j <span style=color:#ff79c6>&lt;</span> COLS; j<span style=color:#ff79c6>+</span><span style=color:#ff79c6>+</span>) {
        sum <span style=color:#ff79c6>+</span><span style=color:#ff79c6>=</span> matrix[i][j];  <span style=color:#6272a4>// 连续内存访问，空间局部性佳
</span><span style=color:#6272a4></span>    }
}

<span style=color:#6272a4>// 列优先遍历（缓存灾难）
</span><span style=color:#6272a4></span><span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> j <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>0</span>; j <span style=color:#ff79c6>&lt;</span> COLS; j<span style=color:#ff79c6>+</span><span style=color:#ff79c6>+</span>) {
    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>0</span>; i <span style=color:#ff79c6>&lt;</span> ROWS; i<span style=color:#ff79c6>+</span><span style=color:#ff79c6>+</span>) {
        sum <span style=color:#ff79c6>+</span><span style=color:#ff79c6>=</span> matrix[i][j];  <span style=color:#6272a4>// 跳跃式访问，每次跨越行长度
</span><span style=color:#6272a4></span>    }
}
</code></pre></div><h3 id=indirect-call>indirect call</h3><p>indirect call包含对虚函数的调用、对函数指针或std::function的调用。在Gluten + CH Backend中更常见的indirect call是前一种情况，即虚函数调用。C++通过虚函数调用实现了动态分发，CH中IFunction, IColumn, IProcessor, IDataType都定义了虚函数接口，方便进行各种功能扩展。</p><p>但是虚函数调用是有代价的，相比普通调用多消耗几十个cycles。虚函数调用过程如下：</p><ul><li>首先程序初始化时C++会为每个包含虚函数的类生成一个虚表，每个对象实例的头部会嵌入一个指向虚表的指针vptr。</li><li>然后运行中调用虚函数时，会从对象的vptr找到对应类的虚表，从虚表中找到对应函数的地址，最后跳转到该地址中执行。</li></ul><p>从cpu视角看，调用虚函数的过程包含了两次内存访问和一次函数调用，另外虚函数会阻碍其被内联优化，当虚函数体量较小时，进入函数和退出函数的额外指令对性能的影响无法忽略。</p><h3 id=page-fault>page fault</h3><p>页错误是操作系统内存管理机制中的一种中断事件，当进程尝试访问的虚拟内存页未映射到物理内存时触发。page fault会导致CPU暂停当前进程的执行，转而执行操作系统的异常处理程序，将物理内存页映射到虚拟内存中, 此过程耗时us级。</p><p>在native engine中，典型的导致page fault的原因有</p><ul><li>未预先分配足够多的内存，导致频繁realloc，每次realloc不仅会触发page fault, 还会导致大量memcpy。</li><li>内存池实现或配置不合理，导致过早归还内存给操作系统。</li></ul><h3 id=自动向量化失败>自动向量化失败</h3><p>向量化是native engine的核心技术，向量化是指通过使用SIMD并行指令替代循环中的标量指令, 提升计算密集型任务的性能，X86下常用的SIMD指令集有SSE4、AVX2和AVX512。</p><p>当循环代码满足一定的条件时，编译器能够对循环进行自动向量化优化。但是这个条件比较苛刻，以下是导致自动向量化失败的一些常见原因：</p><ul><li>循环依赖：迭代之间存在数据依赖</li><li>条件分支</li><li>函数调用</li><li>指针别名</li></ul><h2 id=其他>其他</h2><p>当然还有其他导致Gluten性能瓶颈的因素，如算子Fallback, 算子Spill。</p><p>算子Fallback会引入额外的行列转换，增加了很多不必要的计算，可通过支持该算子的列式执行解决。例如<a href=https://github.com/apache/incubator-gluten/pull/574>Support generate exec</a>支持了lateral view explode算子的列式执行，不仅消除了算子Fallback, native算子的性能还是jvm中算子的3倍。</p><p>算子Spill的目的，是使executor在内存紧张的情况下，将算子中的一部分数据先从内存spill到磁盘中，待内存宽裕时再从磁盘读取到内存中。算子Spill会引入额外的IO和序列化/反序列化开销，必然会使Gluten变慢。但是在生产环境中内存资源是有限的，性能和内存占用始终是一对trade-off，除非算子本身还有改进空间。</p><h2 id=总结>总结</h2><p>本文总结了在Gluten + CH backend 性能优化过程中的主要问题与挑战，包括同步远程IO带来的阻塞、计划优化不充分、CPU执行效率不高等方面。针对这些瓶颈，文章分析了具体原因，如同步IO模型导致CPU空闲、压缩文件分区读取受限、优化规则未完全覆盖、低效的算法实现、循环中的分支和缓存未命中、虚函数调用、页错误以及自动向量化失败等。最后指出，算子Fallback和Spill也会影响整体性能。整体来看，只有从IO、执行计划、CPU利用率等多维度持续优化，才能充分发挥Gluten + CH backend的性能优势。</p><h2 id=参考>参考</h2><ul><li>vtune profiler cookbook: <a href=https://www.intel.com/content/www/us/en/docs/vtune-profiler/cookbook/2024-1/>https://www.intel.com/content/www/us/en/docs/vtune-profiler/cookbook/2024-1/</a></li><li>clickhouse performance optimizations: <a href=https://presentations.clickhouse.com/meetup63/clickhouse_performance_optimizations>https://presentations.clickhouse.com/meetup63/clickhouse_performance_optimizations</a></li></ul></div><div class=post-copyright><p class=copyright-item><span class=item-title>文章作者</span>
<span class=item-content>后端侠</span></p><p class=copyright-item><span class=item-title>上次更新</span>
<span class=item-content>2025-05-23</span></p></div><footer class=post-footer><div class=post-tags><a href=/tags/gluten/>gluten</a>
<a href=/tags/clickhouse/>clickhouse</a>
<a href=/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/>性能优化</a></div><nav class=post-nav><a class=prev href=/post/gluten+ch-backend%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E5%B7%A5%E5%85%B7%E7%AF%87/><i class="iconfont icon-left"></i><span class="prev-text nav-default">Gluten+CH backend性能优化--工具篇</span>
<span class="prev-text nav-mobile">上一篇</span></a>
<a class=next href=/post/gluten+ch-backend%E4%BB%8B%E7%BB%8D/><span class="next-text nav-default">Gluten+CH backend介绍</span>
<span class="next-text nav-mobile">下一篇</span>
<i class="iconfont icon-right"></i></a></nav></footer></article></div><script src=https://utteranc.es/client.js repo=BackendHouse/hugo-comment issue-term=pathname theme=github-light crossorigin=anonymous async></script><noscript>Please enable JavaScript to view the <a href=https://github.com/utterance>comments powered by utterances.</a></noscript></div></main><footer id=footer class=footer><div class=social-links><a href=http://github.com/%e5%90%8e%e7%ab%af%e4%be%a0 class="iconfont icon-github" title=github></a><a href=https://backendhouse.github.io/index.xml type=application/rss+xml class="iconfont icon-rss" title=rss></a></div><div class=copyright><span class=power-by>由 <a class=hexo-link href=https://gohugo.io>Hugo</a> 强力驱动</span>
<span class=division>|</span>
<span class=theme-info>主题 -
<a class=theme-link href=https://github.com/olOwOlo/hugo-theme-even>Even</a></span>
<span class=copyright-year>&copy;
2020 -
2025<span class=heart><i class="iconfont icon-heart"></i></span><span>后端侠</span></span></div></footer><div class=back-to-top id=back-to-top><i class="iconfont icon-up"></i></div></div><script src="/lib/highlight/highlight.pack.js?v=20171001"></script><script src=https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin=anonymous></script><script type=text/javascript src=/js/main.min.c12618f9a600c40bd024996677e951e64d3487006775aeb22e200c990006c5c7.js></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-SYKLLYTW9K"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments);}
gtag('js',new Date());gtag('config','G-SYKLLYTW9K');</script></body></html>