<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><title>- 后端技术小屋</title><meta name=renderer content="webkit"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv=cache-control content="no-transform"><meta http-equiv=cache-control content="no-siteapp"><meta name=theme-color content="#f8f5ec"><meta name=msapplication-navbutton-color content="#f8f5ec"><meta name=apple-mobile-web-app-capable content="yes"><meta name=apple-mobile-web-app-status-bar-style content="#f8f5ec"><meta name=author content="后端侠"><meta name=description content="书接上回，继续阅读第七章(The efficiency of different C++ constructs)
The efficiency of different C++ constructs 循环 循环的效率取决于微处理器对循环控制分支的预测能力。一个具有一个较小并且固定的重复计数，没有分支的循环，可以完美地被预测。
循环展开 展开前
int i; for (i = 0; i &amp;lt; 20; i++) { if (i % 2 == 0); FuncA(i); else FuncB(i); FuncC(i); } 展开后
int i; for (i = 0; i &amp;lt; 20; i+=2) { FuncA(i); FuncC(i); FuncB(i+1); FuncC(i+1); } 这样做的好处：
 循环次数变成了10次而不是20次，CPU可以更完美的进行预测 if分支被消除，有利于编译器自动进行向量化等优化  循环展开的坏处：
  展开循环后在代码缓存中占用更多空间
  非常小的循环展开不如不展开
  如果重复计数为奇数，并将其展开为2， 则必须在循环之外执行额外的迭代。"><meta name=keywords content="Hugo,theme,后端侠"><meta name=generator content="Hugo 0.62.2 with theme even"><link rel=canonical href=https://backendhouse.github.io/post/optimizing-software-in-c++%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%BA%8C/><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/manifest.json><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link href=/sass/main.min.a2095472a2a8d7ddda1334cf60051cbe40ed55f2467554bb6aa4c17c9bcd27a4.css rel=stylesheet><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin=anonymous><meta property="og:title" content><meta property="og:description" content="书接上回，继续阅读第七章(The efficiency of different C++ constructs)
The efficiency of different C++ constructs 循环 循环的效率取决于微处理器对循环控制分支的预测能力。一个具有一个较小并且固定的重复计数，没有分支的循环，可以完美地被预测。
循环展开 展开前
int i; for (i = 0; i < 20; i++) { if (i % 2 == 0); FuncA(i); else FuncB(i); FuncC(i); } 展开后
int i; for (i = 0; i < 20; i+=2) { FuncA(i); FuncC(i); FuncB(i+1); FuncC(i+1); } 这样做的好处：
 循环次数变成了10次而不是20次，CPU可以更完美的进行预测 if分支被消除，有利于编译器自动进行向量化等优化  循环展开的坏处：
  展开循环后在代码缓存中占用更多空间
  非常小的循环展开不如不展开
  如果重复计数为奇数，并将其展开为2， 则必须在循环之外执行额外的迭代。"><meta property="og:type" content="article"><meta property="og:url" content="https://backendhouse.github.io/post/optimizing-software-in-c++%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%BA%8C/"><meta itemprop=name content><meta itemprop=description content="书接上回，继续阅读第七章(The efficiency of different C++ constructs)
The efficiency of different C++ constructs 循环 循环的效率取决于微处理器对循环控制分支的预测能力。一个具有一个较小并且固定的重复计数，没有分支的循环，可以完美地被预测。
循环展开 展开前
int i; for (i = 0; i < 20; i++) { if (i % 2 == 0); FuncA(i); else FuncB(i); FuncC(i); } 展开后
int i; for (i = 0; i < 20; i+=2) { FuncA(i); FuncC(i); FuncB(i+1); FuncC(i+1); } 这样做的好处：
 循环次数变成了10次而不是20次，CPU可以更完美的进行预测 if分支被消除，有利于编译器自动进行向量化等优化  循环展开的坏处：
  展开循环后在代码缓存中占用更多空间
  非常小的循环展开不如不展开
  如果重复计数为奇数，并将其展开为2， 则必须在循环之外执行额外的迭代。"><meta itemprop=wordCount content="267"><meta itemprop=keywords content><meta name=twitter:card content="summary"><meta name=twitter:title content><meta name=twitter:description content="书接上回，继续阅读第七章(The efficiency of different C++ constructs)
The efficiency of different C++ constructs 循环 循环的效率取决于微处理器对循环控制分支的预测能力。一个具有一个较小并且固定的重复计数，没有分支的循环，可以完美地被预测。
循环展开 展开前
int i; for (i = 0; i < 20; i++) { if (i % 2 == 0); FuncA(i); else FuncB(i); FuncC(i); } 展开后
int i; for (i = 0; i < 20; i+=2) { FuncA(i); FuncC(i); FuncB(i+1); FuncC(i+1); } 这样做的好处：
 循环次数变成了10次而不是20次，CPU可以更完美的进行预测 if分支被消除，有利于编译器自动进行向量化等优化  循环展开的坏处：
  展开循环后在代码缓存中占用更多空间
  非常小的循环展开不如不展开
  如果重复计数为奇数，并将其展开为2， 则必须在循环之外执行额外的迭代。"><!--[if lte IE 9]><script src=https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js></script><![endif]--><!--[if lt IE 9]><script src=https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js></script><script src=https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js></script><![endif]--></head><body><div id=mobile-navbar class=mobile-navbar><div class=mobile-header-logo><a href=/ class=logo>后端技术小屋</a></div><div class=mobile-navbar-icon><span></span><span></span><span></span></div></div><nav id=mobile-menu class="mobile-menu slideout-menu"><ul class=mobile-menu-list><a href=/><li class=mobile-menu-item>Home</li></a><a href=/post/><li class=mobile-menu-item>Archives</li></a><a href=/tags/><li class=mobile-menu-item>Tags</li></a><a href=/categories/><li class=mobile-menu-item>Categories</li></a><a href=/about/><li class=mobile-menu-item>About</li></a></ul></nav><div class=container id=mobile-panel><header id=header class=header><div class=logo-wrapper><a href=/ class=logo>后端技术小屋</a></div><nav class=site-navbar><ul id=menu class=menu><li class=menu-item><a class=menu-item-link href=/>Home</a></li><li class=menu-item><a class=menu-item-link href=/post/>Archives</a></li><li class=menu-item><a class=menu-item-link href=/tags/>Tags</a></li><li class=menu-item><a class=menu-item-link href=/categories/>Categories</a></li><li class=menu-item><a class=menu-item-link href=/about/>About</a></li></ul></nav></header><main id=main class=main><div class=content-wrapper><div id=content class=content><article class=post><header class=post-header><h1 class=post-title></h1><div class=post-meta><span class=post-time>0001-01-01</span></div></header><div class=post-toc id=post-toc><h2 class=post-toc-title>文章目录</h2><div class="post-toc-content always-active"><nav id=TableOfContents><ul><li><a href=#the-efficiency-of-different-c-constructs>The efficiency of different C++ constructs</a><ul><li><a href=#循环>循环</a><ul><li><a href=#循环展开>循环展开</a></li><li><a href=#循环控制条件>循环控制条件</a></li><li><a href=#复制或清除数组>复制或清除数组</a></li></ul></li><li><a href=#函数>函数</a><ul><li><a href=#避免不必要函数>避免不必要函数</a></li><li><a href=#使用内联函数>使用内联函数</a></li><li><a href=#避免在最内层循环嵌套函数调用>避免在最内层循环嵌套函数调用</a></li><li><a href=#使用宏代替函数>使用宏代替函数</a></li><li><a href=#使函数局部化>使函数局部化</a></li><li><a href=#使用全程序优化>使用全程序优化</a></li><li><a href=#使用64位模式>使用64位模式</a></li></ul></li><li><a href=#函数参数>函数参数</a></li><li><a href=#函数返回类型>函数返回类型</a></li><li><a href=#函数尾调用>函数尾调用</a></li><li><a href=#递归函数>递归函数</a></li><li><a href=#结构体和类>结构体和类</a></li><li><a href=#类的数据成员>类的数据成员</a></li><li><a href=#类的成员函数>类的成员函数</a></li><li><a href=#虚成员函数>虚成员函数</a></li><li><a href=#运行时类型识别rtti>运行时类型识别（RTTI）</a></li><li><a href=#继承>继承</a></li><li><a href=#联合体>联合体</a></li><li><a href=#位域>位域</a></li><li><a href=#重载函数>重载函数</a></li><li><a href=#重载运算符>重载运算符</a></li><li><a href=#模板>模板</a><ul><li><a href=#使用模板实现编译时多态>使用模板实现编译时多态</a></li></ul></li><li><a href=#线程>线程</a></li><li><a href=#异常和错误处理>异常和错误处理</a><ul><li><a href=#异常和向量代码>异常和向量代码</a></li><li><a href=#避免异常处理的成本>避免异常处理的成本</a></li><li><a href=#编写异常安全代码>编写异常安全代码</a></li></ul></li><li><a href=#nan和inf的传递>NAN和INF的传递</a></li><li><a href=#预处理命令>预处理命令</a></li><li><a href=#命名空间>命名空间</a></li></ul></li></ul></nav></div></div><div class=post-content><p>书接上回，继续阅读第七章(The efficiency of different C++ constructs)</p><h1 id=the-efficiency-of-different-c-constructs>The efficiency of different C++ constructs</h1><h2 id=循环>循环</h2><p>循环的效率取决于微处理器对循环控制分支的预测能力。一个具有一个较小并且固定的重复计数，没有分支的循环，可以完美地被预测。</p><h3 id=循环展开>循环展开</h3><p>展开前</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#8be9fd>int</span> i;
<span style=color:#ff79c6>for</span> (i <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>0</span>; i <span style=color:#ff79c6>&lt;</span> <span style=color:#bd93f9>20</span>; i<span style=color:#ff79c6>+</span><span style=color:#ff79c6>+</span>)
{
	<span style=color:#ff79c6>if</span> (i <span style=color:#ff79c6>%</span> <span style=color:#bd93f9>2</span> <span style=color:#ff79c6>=</span><span style=color:#ff79c6>=</span> <span style=color:#bd93f9>0</span>); 
		FuncA(i);
	<span style=color:#ff79c6>else</span>
		<span style=color:#50fa7b>FuncB</span>(i);
	FuncC(i);
}
</code></pre></div><p>展开后</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#8be9fd>int</span> i;
<span style=color:#ff79c6>for</span> (i <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>0</span>; i <span style=color:#ff79c6>&lt;</span> <span style=color:#bd93f9>20</span>; i<span style=color:#ff79c6>+</span><span style=color:#ff79c6>=</span><span style=color:#bd93f9>2</span>)
{
    FuncA(i);
   	FuncC(i);
    FuncB(i<span style=color:#ff79c6>+</span><span style=color:#bd93f9>1</span>);
	FuncC(i<span style=color:#ff79c6>+</span><span style=color:#bd93f9>1</span>);
}
</code></pre></div><p>这样做的好处：</p><ul><li>循环次数变成了10次而不是20次，CPU可以更完美的进行预测</li><li>if分支被消除，有利于编译器自动进行向量化等优化</li></ul><p>循环展开的坏处：</p><ul><li><p>展开循环后在代码缓存中占用更多空间</p></li><li><p>非常小的循环展开不如不展开</p></li><li><p>如果重复计数为奇数，并将其展开为2， 则必须在循环之外执行额外的迭代。</p></li></ul><p>只有在能够取得特定好处的情况下，才应该使用循环展开。如果一个循环包含浮点运算，且循环计数器是整数，那么通常可
以假设整个计算时间是由浮点代码决定的，而不是由循环控制分支决定的。在这种情况下，展开循环是没有任何好处的 。</p><h3 id=循环控制条件>循环控制条件</h3><p>如果循环控制分支依赖于循环内部的计算，则效率较低。</p><p>确定最坏情况下的最大重复计数并始终使用此迭代次数的效率会更高。</p><p>循环计数器最好是整数。</p><h3 id=复制或清除数组>复制或清除数组</h3><p>对于诸如复制数组或将数组中的元素全部设置为零这样的琐碎任务，使用循环可能不是最佳选择。使用memset和memcpy函数通常会更快</p><h2 id=函数>函数</h2><p>函数调用会让程序慢下来，因为</p><ul><li>代码地址跳转，可能需要4个时钟周期</li><li>如果代码分散在内存中会降低代码缓存效率</li><li>如果函数参数不够放在寄存器中，需要入到栈中，效率不高</li><li>需要额外时间设置stack frame, 保存和恢复寄存器</li><li>每个函数调用语句需要在分支目标缓冲区（BTB）中占用空间 , BTB争用可能会导致分支预测失败</li></ul><p>如何避免函数调用降低效率呢？</p><h3 id=避免不必要函数>避免不必要函数</h3><p>不要过度封装</p><h3 id=使用内联函数>使用内联函数</h3><p>如果函数很小，或者只在程序中的一个位置调用它，那么内联函数是有好处的。小函数通常由编译器自动内联</p><h3 id=避免在最内层循环嵌套函数调用>避免在最内层循环嵌套函数调用</h3><p>如果程序关键的最内层循环包含对帧函数的调用，那么代码有可能通过内联帧函数或使帧函数调用的所有函数内联（把帧函数变为叶函数）来提升效率</p><h3 id=使用宏代替函数>使用宏代替函数</h3><p>但是不要滥用宏，宏的问题是：名称不能重载或限制作用区域。宏将干扰具有相同名称的任何函数或变量，而与作用域或命名空间无关</p><h3 id=使函数局部化>使函数局部化</h3><p>应该使同一个模块中使用的函数（即当前*.cpp* 文件）是局部的。 这使得编译器更容易将函数内联，并对函数调用进行优
化。</p><p>如何使函数局部化呢？</p><ul><li>对于非类成员函数，直接使用static</li><li>对于类成员函数，将函数或类放置于匿名命名空间中</li></ul><h3 id=使用全程序优化>使用全程序优化</h3><p>一些编译器具有对整个程序进行优化的选项，也可以选择将多个 .cpp 文件组合成一个对象文件。这使得编译器能够在组成程
序的所有 .cpp 模块之间优化寄存器分配和参数传递。</p><h3 id=使用64位模式>使用64位模式</h3><p>现在服务器端开发都是64位模式了吧</p><h2 id=函数参数>函数参数</h2><p>在大多数情况下，函数参数是按值传递的。这意味着参数的值被复制到一个局部变量中。对于int、float、double、bool、enum 以及指针和引用等简单类型，这非常快。</p><p>数组总是使用指针传递，除非它们被打包在类或者结构体中。</p><p>如果参数是复合类型，在以下情况下传值更高效，否则使用指针和引用更高效</p><ul><li>对象很小，可以装入一个寄存器</li><li>对象没有拷贝构造函数和析构函数</li><li>对象没有虚成员</li><li>对象没有使用RTTI</li></ul><p>将复合对象传递给函数的首选方法是使用const引用。其次是使函数成为对象的类成员</p><p>64位unix系统允许寄存器中传输最多14个参数(8个float或double, 加上6个整数、指针或引用参数)</p><h2 id=函数返回类型>函数返回类型</h2><p>函数的返回类型最好是简单类型、指针、引用或 void。返回复合类型的对象更为复杂，而且常常效率低下。</p><p>简单情况下，复合类型对象直接从寄存器返回。否则通过一个隐藏指针将它们复制到调用方指定的位置。</p><p>当直接返回复杂类型对象的值时，编译器可能会进行RVO(return value optimization)优化，从而避免复制构造和析构成本，但开发者不应依赖这一点。</p><h2 id=函数尾调用>函数尾调用</h2><p>尾调用是优化函数调用的一种方法。如果函数的最后一条语句是对另一个函数的调用，那么编译器可以用跳转到第二个函数
来替换该调用。 优化编译器将自动完成此任务。第二个函数不会返回到第一个函数，而是直接返回第一个函数被调用的位
置。这样效率更高，因为它消除了返回操作。</p><h2 id=递归函数>递归函数</h2><p>函数递归调用对于处理递归数据结构非常有用。递归函数的代价是所有参数和局部变量在每次递归时都会有一个新实例，这会占用栈空间。</p><p>较宽的树形结构比较深的树形结构，有更高的递归效率 .</p><p>无分支递归总是可以用循环代替，这样的效率更高</p><h2 id=结构体和类>结构体和类</h2><p>面向对象的好处</p><ul><li>变量存储在一起，数据缓存更有效率</li><li>无需将类成员变量作为参数传递给类成员函数，避免参数传递的开销</li></ul><p>面向对象的坏处：</p><ul><li>非静态成员函数有this指针，有额外开销</li><li>虚成员函数的效率较低</li></ul><p>如果面向对象的编程风格有利于程序的逻辑结构和清晰性，那么你可以使用这种风格</p><h2 id=类的数据成员>类的数据成员</h2><p>类或结构体的数据成员是按创建类或结构实例时声明它们的顺序连续存储。将数据组织到类或结构体中不存在性能损失。</p><p>大多数编译器将数据成员对齐到可以被特定数整除的地址以优化访问，副作用是产生字节空洞</p><h2 id=类的成员函数>类的成员函数</h2><p>每次声明或创建类的新对象时，它都会生成数据成员的新实例。但是每个成员函数只有一个实例。函数代码不会被复制</p><p>静态成员函数不能访问任何非静态数据成员或非静态成员函数。静态成员函数比非静态成员函数快。</p><h2 id=虚成员函数>虚成员函数</h2><p>多态性是面向对象程序比非面向对象程序效率低的主要原因之一。 如果可以避免使用虚函数，那么你就可以获得面向对象编程的大多数优势，而无需付出性能成本 。</p><p>如果函数调用语句总是调用虚函数的相同版本，那么调用虚成员函数所花费的时间要比调用非虚成员函数多几个时钟周期。 如果版本发生了变化，你可能会得到10 ‐ 20个时钟周期的错误预测惩罚。</p><p>有时可以使用模板而不是虚函数来获得所需的多态性效果。</p><h2 id=运行时类型识别rtti>运行时类型识别（RTTI）</h2><p>效率不高。如果编译器有RTTI 选项，那么关闭它并使用其他实现。</p><h2 id=继承>继承</h2><p>派生类的对象与包含父类和子类成员的简单类的对象的实现方法相同。父类和子类的成员访问速度相同。一般来说，你可以
假设使用继承几乎没有任何性能损失。 除了</p><ul><li>父类数据成员大小会添加到子类成员的偏移量中。偏移量太大时，会造成数据缓存效率降低</li><li>父类和子类代码可能在不同模块。造成代码缓存效率降低</li></ul><p>尽量不使用多重继承，代之以组合</p><h2 id=联合体>联合体</h2><p>union 是数据成员共享相同内存空间的结构。union 可以通过允许从不同时使用的两个数据成员共享同一块内存来节省内存
空间。</p><h2 id=位域>位域</h2><p>位域可能有助于使数据更加紧凑。访问位域成员不如访问结构的成员效率高。如果在大数组可以节省缓存空间或使文件更
小，那么额外的时间是合理的</p><h2 id=重载函数>重载函数</h2><p>重载函数的不同版本被简单地视为不同的函数。使用重载函数没有性能损失</p><h2 id=重载运算符>重载运算符</h2><p>重载的运算符相当于一个函数。使用重载运算符与使用具有相同功能的函数效率一样</p><h2 id=模板>模板</h2><p>模板与宏的相似之处在于，模板参数在编译之前被它们的值所替换</p><p>模板是高效的，因为模板参数总是在编译时被解析。模板使源代码更加复杂，而不是编译后的代码。一般来说，使用模板在
执行速度方面没有任何成本</p><h3 id=使用模板实现编译时多态>使用模板实现编译时多态</h3><p>模板类可用于实现编译时多态性，这比使用虚拟成员函数获得的运行时多态性更加高效</p><p>模板代码可读性不佳。如果编译器能够自动执行去虚拟化(去掉动态绑定时对虚函数表的查询), 那么依赖编译器优化肯定比使用这种复杂的模板方法更加方便。</p><h2 id=线程>线程</h2><p>线程上下文切换非常耗时，可通过设置更长的时间片来减少上下文切换的次数。</p><p>为不同任务的不同线程分配不同的优先级是非常有用的</p><p>为了充分利用多核，我们将工作划分成多个线程，每个线程在单独的cpu core上执行。但是多线程有四个成本：</p><ul><li>启动和停止线程的成本。如果任务执行时间很短，不要为其单独分配线程</li><li>线程切换成本。</li><li>线程间同步和通信成本。</li><li>不同线程需要单独的存储空间，线程有各自的堆栈，如果线程共享相同的缓存，可能会导致缓存竞争。</li></ul><p>多线程程序必须使用线程安全函数，线程安全函数永远不应该使用静态变量(除非只读)</p><h2 id=异常和错误处理>异常和错误处理</h2><p>c++中通过try catch捕获异常。异常处理旨在检测很少发生的错误，并以一种优雅的方式从错误条件中恢复</p><p>虽然程序运行时没有错误，但是异常处理仍需要额外的时间，花销多少取决于编译器实现。</p><p>如果你的应用程序不需要异常处理，那么应该禁用它，以便使代码更小、更高效。你可以通过关闭编译器中的异常处理选项来禁
用整个程序的异常处理。你也可以通过向函数原型中添加 throw() 声明来禁用单个函数的异常处理：</p><h3 id=异常和向量代码>异常和向量代码</h3><p>向量指令对于并行执行多个计算是有用的。</p><p>如果代码可以从向量指令中获益，那么最好禁用异常捕获，转而依赖 NAN 和 INF 的传递。</p><h3 id=避免异常处理的成本>避免异常处理的成本</h3><p>当不需要尝试从错误中恢复时，不需要异常处理。</p><p>建议使用系统的、经过深思熟虑的方法来处理错误。你必须区分可恢复错误和不可恢复错误；确保分配的资源在发生错误时
得到清理；并向用户发送适当的错误消息。</p><h3 id=编写异常安全代码>编写异常安全代码</h3><p>为了保证异常安全，需要在发生异常时清理资源</p><ul><li>使用new和malloc分配的内存</li><li>句柄</li><li>互斥量</li><li>数据库连接</li><li>网络连接</li><li>待删除临时文件</li><li>待保护的用户工作</li><li>其他已分配的资源</li></ul><p>C++ 处理清理工作的方法是创建一个析构函数。C++ 异常处理系统确保调用本地对象的所有析构函数。 如果包装器类有析构函数来处理分配资源的所有清理工作，则程序是异常安全的。如果析构函数引发另一个异常，则系统可能会出现问题。</p><p>如果你使用自己的错误处理系统而不是使用异常处理，那么你无法确保调用了所有析构函数并清理了资源。如果错误处理程
序调用 exit()、abort()、_endthread() 等，则不能保证所有析构函数被调用</p><h2 id=nan和inf的传递>NAN和INF的传递</h2><p>浮点溢出和除以 0 得到无穷大。如果你把无穷大和某数相加或相乘，结果就是无穷大。 如果用一个正常的数字除以INF，会得到0 。特殊情况INF‐INF和INF/INF得到NAN （not‐a‐number）。当你用 0 除以 0 以及函数的输入超出范围时，比如sqrt(‐1)和log(‐1)，也会出现
特殊的代码NAN。</p><p>INF 和 NAN 的传播也不需要额外的成本</p><p>当参数为 INF 或 NAN 时，函数 finite() 将返回 false，如果它是一个普通的浮点数，则返回 true。</p><h2 id=预处理命令>预处理命令</h2><p>就程序性能而言，预处理指令（以#开头的所有指令）的性能成本很少，因为它们在程序编译之前就已经解析了</p><h2 id=命名空间>命名空间</h2><p>使用名称空间，对执行速度没有影响</p></div><div class=post-copyright><p class=copyright-item><span class=item-title>文章作者</span>
<span class=item-content>后端侠</span></p><p class=copyright-item><span class=item-title>上次更新</span>
<span class=item-content>0001-01-01</span></p></div><footer class=post-footer><nav class=post-nav><a class=prev href=/post/optimizing-software-in-c++%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B8%80-the-efficiency-of-different-c++-constructs-/><i class="iconfont icon-left"></i><span class="prev-text nav-default"></span><span class="prev-text nav-mobile">上一篇</span></a></nav></footer></article></div><script src=https://utteranc.es/client.js repo=BackendHouse/hugo-comment issue-term=pathname theme=github-light crossorigin=anonymous async></script><noscript>Please enable JavaScript to view the <a href=https://github.com/utterance>comments powered by utterances.</a></noscript></div></main><footer id=footer class=footer><div class=social-links><a href=http://github.com/%e5%90%8e%e7%ab%af%e4%be%a0 class="iconfont icon-github" title=github></a><a href=https://backendhouse.github.io/index.xml type=application/rss+xml class="iconfont icon-rss" title=rss></a></div><div class=copyright><span class=power-by>由 <a class=hexo-link href=https://gohugo.io>Hugo</a> 强力驱动</span>
<span class=division>|</span>
<span class=theme-info>主题 -
<a class=theme-link href=https://github.com/olOwOlo/hugo-theme-even>Even</a></span>
<span class=copyright-year>&copy;
2020 -
2025<span class=heart><i class="iconfont icon-heart"></i></span><span>后端侠</span></span></div></footer><div class=back-to-top id=back-to-top><i class="iconfont icon-up"></i></div></div><script src="/lib/highlight/highlight.pack.js?v=20171001"></script><script src=https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin=anonymous></script><script type=text/javascript src=/js/main.min.c12618f9a600c40bd024996677e951e64d3487006775aeb22e200c990006c5c7.js></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-SYKLLYTW9K"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments);}
gtag('js',new Date());gtag('config','G-SYKLLYTW9K');</script></body></html>