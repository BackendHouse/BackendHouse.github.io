<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><title>《Velox: Meta’s Unified Execution Engine》笔记 - 后端技术小屋</title><meta name=renderer content="webkit"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv=cache-control content="no-transform"><meta http-equiv=cache-control content="no-siteapp"><meta name=theme-color content="#f8f5ec"><meta name=msapplication-navbutton-color content="#f8f5ec"><meta name=apple-mobile-web-app-capable content="yes"><meta name=apple-mobile-web-app-status-bar-style content="#f8f5ec"><meta name=author content="后端侠"><meta name=description content="背景 现在业界中针对特定工作负载的计算引擎太多，导致计算引擎孤岛化。他们之间难以共享一些通用的优化手段。Velox就是为了解决这个问题而生的，"><meta name=keywords content="Hugo,theme,后端侠"><meta name=generator content="Hugo 0.62.2 with theme even"><link rel=canonical href=https://backendhouse.github.io/post/velox-metas-unified-execution-engine%E7%AC%94%E8%AE%B0/><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/manifest.json><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link href=/sass/main.min.a2095472a2a8d7ddda1334cf60051cbe40ed55f2467554bb6aa4c17c9bcd27a4.css rel=stylesheet><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin=anonymous><meta property="og:title" content="《Velox: Meta’s Unified Execution Engine》笔记"><meta property="og:description" content="背景 现在业界中针对特定工作负载的计算引擎太多，导致计算引擎孤岛化。他们之间难以共享一些通用的优化手段。Velox就是为了解决这个问题而生的，"><meta property="og:type" content="article"><meta property="og:url" content="https://backendhouse.github.io/post/velox-metas-unified-execution-engine%E7%AC%94%E8%AE%B0/"><meta property="article:published_time" content="2025-05-20T18:14:05+08:00"><meta property="article:modified_time" content="2025-05-20T18:14:05+08:00"><meta itemprop=name content="《Velox: Meta’s Unified Execution Engine》笔记"><meta itemprop=description content="背景 现在业界中针对特定工作负载的计算引擎太多，导致计算引擎孤岛化。他们之间难以共享一些通用的优化手段。Velox就是为了解决这个问题而生的，"><meta itemprop=datePublished content="2025-05-20T18:14:05+08:00"><meta itemprop=dateModified content="2025-05-20T18:14:05+08:00"><meta itemprop=wordCount content="3259"><meta itemprop=keywords content="paper,"><meta name=twitter:card content="summary"><meta name=twitter:title content="《Velox: Meta’s Unified Execution Engine》笔记"><meta name=twitter:description content="背景 现在业界中针对特定工作负载的计算引擎太多，导致计算引擎孤岛化。他们之间难以共享一些通用的优化手段。Velox就是为了解决这个问题而生的，"><!--[if lte IE 9]><script src=https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js></script><![endif]--><!--[if lt IE 9]><script src=https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js></script><script src=https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js></script><![endif]--></head><body><div id=mobile-navbar class=mobile-navbar><div class=mobile-header-logo><a href=/ class=logo>后端技术小屋</a></div><div class=mobile-navbar-icon><span></span><span></span><span></span></div></div><nav id=mobile-menu class="mobile-menu slideout-menu"><ul class=mobile-menu-list><a href=/><li class=mobile-menu-item>Home</li></a><a href=/post/><li class=mobile-menu-item>Archives</li></a><a href=/tags/><li class=mobile-menu-item>Tags</li></a><a href=/categories/><li class=mobile-menu-item>Categories</li></a><a href=/about/><li class=mobile-menu-item>About</li></a></ul></nav><div class=container id=mobile-panel><header id=header class=header><div class=logo-wrapper><a href=/ class=logo>后端技术小屋</a></div><nav class=site-navbar><ul id=menu class=menu><li class=menu-item><a class=menu-item-link href=/>Home</a></li><li class=menu-item><a class=menu-item-link href=/post/>Archives</a></li><li class=menu-item><a class=menu-item-link href=/tags/>Tags</a></li><li class=menu-item><a class=menu-item-link href=/categories/>Categories</a></li><li class=menu-item><a class=menu-item-link href=/about/>About</a></li></ul></nav></header><main id=main class=main><div class=content-wrapper><div id=content class=content><article class=post><header class=post-header><h1 class=post-title>《Velox: Meta’s Unified Execution Engine》笔记</h1><div class=post-meta><span class=post-time>2025-05-20</span><div class=post-category><a href=/categories/paper/>paper</a></div></div></header><div class=post-toc id=post-toc><h2 class=post-toc-title>文章目录</h2><div class="post-toc-content always-active"><nav id=TableOfContents></nav></div></div><div class=post-content><p><strong>背景</strong>
现在业界中针对特定工作负载的计算引擎太多，导致计算引擎孤岛化。他们之间难以共享一些通用的优化手段。<a href="https://zhida.zhihu.com/search?content_id=256334092&content_type=Article&match_order=1&q=Velox&zhida_source=entity">Velox</a>就是为了解决这个问题而生的，它是一个开源的c++数据库加速库。Velox 提供了可重用、可扩展、高性能且方言无关的数据处理组件，用于构建执行引擎和增强数据管理系统。该库高度依赖<a href="https://zhida.zhihu.com/search?content_id=256334092&content_type=Article&match_order=1&q=%E5%90%91%E9%87%8F%E5%8C%96&zhida_source=entity">向量化</a>和自适应，从头开始设计以支持对复杂数据类型的高效计算，因为这些数据类型在现代工作负载中无处不在。目前，Velox 已集成或正在集成到 Meta 的十多个数据系统中，它在以下方面提供了好处：（a) 全面吸收了以前仅在个别引擎中发现的优化，提高了性能；（b）提高了数据用户的一致性；（c）通过促进可重用性提高了工程效率。</p><p><strong>目标</strong></p><p>运行效率：Velox 充分吸收了以前在各个引擎中实现的运行时优化（如充分利用 SIMD、Lazy Evaluation、<a href="https://zhida.zhihu.com/search?content_id=256334092&content_type=Article&match_order=1&q=%E8%87%AA%E9%80%82%E5%BA%94%E8%B0%93%E8%AF%8D%E9%87%8D%E6%8E%92&zhida_source=entity">自适应谓词重排</a>和下推、公共子表达式消除、对编码数据的执行、代码生成等）。</p><p>语义一致性：通过相同的执行库，计算引擎在相同输入下可以返回一致的输出，保证了不同计算引擎之间的语义一致性。</p><p>工程效率：通过对Velox的集中维护，从而减少工程重复并促进可重用性。</p><p><strong>Velox Use Case</strong></p><p>presto: Prestissimo项目(<a href="https://link.zhihu.com/?target=https%3A//github.com/prestodb/presto/tree/master/presto-native-execution">https://github.com/prestodb/presto/tree/master/presto-native-execution</a>)，类似apache gluten, 将presto的计划片段offload到velox中去执行，从而获得性能收益。</p><p><a href="https://zhida.zhihu.com/search?content_id=256334092&content_type=Article&match_order=1&q=spark&zhida_source=entity">spark</a>: spruce项目，资料不多</p><p>实时处理：xstream&ndash;流处理，scribe&ndash;消息总线</p><p>机器学习：<a href="https://zhida.zhihu.com/search?content_id=256334092&content_type=Article&match_order=1&q=TorchArrow&zhida_source=entity">TorchArrow</a>--数据预处理，<a href="https://zhida.zhihu.com/search?content_id=256334092&content_type=Article&match_order=1&q=F3&zhida_source=entity">F3</a>--特征工程</p><p><strong>高级组件实现</strong></p><p><strong>类型系统</strong></p><p>包含标量，复杂类型，嵌套类型，包括struct, map, tensor(张量)等，用户可通过接口扩展自定义类型。</p><p><strong>列</strong></p><p>和和arrow兼容的列式布局，支持多种编码：flat/dict/const/rle/bias。</p><p>velox提出了<a href="https://zhida.zhihu.com/search?content_id=256334092&content_type=Article&match_order=1&q=lazy+vectors&zhida_source=entity">lazy vectors</a>的概念，lazy vector只有初次被访问时才会物化，减少物化代价。<a href="https://zhida.zhihu.com/search?content_id=256334092&content_type=Article&match_order=1&q=CH&zhida_source=entity">CH</a>中已实现: <a href="https://link.zhihu.com/?target=https%3A//github.com/ClickHouse/ClickHouse/pull/55518">https://github.com/ClickHouse/ClickHouse/pull/55518</a></p><p>velox提供了zero-copy的decoded vector抽象，提供了统一的访问api, 使得具体vector编码对用户透明</p><p>velox中string vector的设计如下，这样做的好处是</p><ul><li>string vector中每行长度相同，方便随机更行任意索引位置</li><li>StringView中包含长度为4的前缀信息，方便对字符串进行快速筛选</li></ul><p><img src=https://picx.zhimg.com/v2-fe2d12a41b85a9dbbd2b7109da9884c3_1440w.jpg alt></p><p>velox中列的实现支持乱序写。首先原始类型都是定长的，本身就支持乱序写；其次string类型由于其特殊设计也是定长的；最后对于array或map等复杂类型的列实现，维护两个向量分别表示每一列的offset和length, 对array或map column的乱序写就是对内部的offset和length向量的乱序写。这样的设计除了支持乱序写之外，还支持向量切片，向量重排。</p><p>velox中支持了多种column encoding，跟CH类似，这里略过</p><p><strong>表达式计算</strong></p><p>velox表达式计算完全兼容列式格式，优化手段包括：公共子表达式消除，常量折叠，null值传播，encoding-ware evaluation</p><p>velox中表达式由节点组成，节点类型包括literal, function, cast, lambda, input, 大体上和CH相同。</p><p>velox中表达式的运行时优化有公共子表达式消除，常量折叠，自适应谓词重排。自适应谓词重排是将计算代价最小和区分度最大的谓词放在谓词列表的前面，目的是减少谓词计算代价。CH目前只有前两个优化。</p><p>velox表达式计算优化</p><ul><li>如果表达式遵循空值传播规则(func(a,b)中任何参数为null, 输出为null), 且输入为null, 则跳过计算。CH中实现了类似特性：<a href="https://link.zhihu.com/?target=https%3A//github.com/ClickHouse/ClickHouse/pull/73820">https://github.com/ClickHouse/ClickHouse/pull/73820</a></li><li>如果表达式是公共子表达式且已经标记为计算完成，则跳过计算</li></ul><p>dict encoded column的peeling优化：将对字典编码向量的计算转化为对其低基数字典的计算</p><p>dict encoded column的cache优化：如果字典编码向量中的字典是全局的，即使输入包含多个batch, 在计算表达式时也只需要基于字典做一次计算形成一个全局的新字典，然后分别套上每个batch对应的index向量，生成新的dict encoded column</p><p>codegen: 不同于CH生成llvm ir, velox直接生成c++代码并编译，编译时间太长，还只是实验特性</p><p><strong>函数</strong></p><p><strong>标量函数</strong></p><p>velox中函数的实现框架提供了简单的逐行处理接口，方便用户二开，逐行处理时, velox保证循环内函数调用被inline, 提供了编译器自动向量化的可能。同时velox也支持向量化接口。语义上尽量兼容presto和spark，当然不可避免的有diff</p><p>从下图可以看到，逐行处理实现的性能有时候会超过向量实现</p><p><img src=https://pic2.zhimg.com/v2-c0c4890fbd4057cc106b5711667fe47f_1440w.jpg alt></p><p>velox针对字符串函数有特殊优化，当输入只包含ascii字符时，按照ascii对应的实现执行，以提升性能，CH中实现了类似特性：<a href="https://link.zhihu.com/?target=https%3A//github.com/ClickHouse/ClickHouse/pull/61632">https://github.com/ClickHouse/ClickHouse/pull/61632</a>。由于velox对string column的特殊设计，string function的输出列可直接引用输入列中的buffer切片，避免了大量内存分配。</p><p><img src=https://pic1.zhimg.com/v2-42470ff18bf0049ec4a36d4ae1b8f1c0_1440w.jpg alt></p><p><img src=https://pic4.zhimg.com/v2-20076426de1402b2c5285f0b335b1b91_1440w.jpg alt></p><p><strong>聚合函数</strong></p><p>velox聚合函数的实现中有两个优化。目前在CH中都已实现</p><p>第一个优化是单一聚合优化，当没有group by 任何key时，无需创建hash table, 直接对中间状态进行更新，避免了hash table相关开销。</p><p>第二个优化是关于hash table中间状态存储的，如果中间状态是定长的，则直接将其存储于hash table中，否则将其分配于buffer中，hash table中存储指向buffer对应位置的指针</p><p><strong>算子</strong></p><p>包含tablescan, project, filter, aggregate, exchange/merge, orderby, hashjoin, mergejoin, unnest等。</p><p>这里介绍了pipeline概念，pipeline的起点是source/exchange, 终点是exchange/sink。</p><p>velox支持用户自定义算子，例如自定义支持流式计算的聚合算子。</p><p>tablescan的优化，过滤下推和延迟物化。</p><p>filter的优化</p><ul><li>谓词重排</li><li>in表达式优化(这里没看懂?，原文:Velox also provides an efficient implementation for large IN filters, used for hash join pushdown, which allows it to trigger 4 cache misses at a time.)</li><li>filter和project结合成filterproject, 在其实现中，filter expr和project expr在同一个DAG中，对输入数据，首先计算filter expr结果，然后以其作为掩码计算project expr。velox能这么优化也是得益于其向量设计。</li></ul><p>aggregate和join的优化：核心在于hash table.</p><ul><li>当所有group by key只映射到很小的整数域，直接将hash table转化为array</li><li>join build端根据key生成bloom filter, 对join probe端底层的scan使用这个</li></ul><p><strong>IO</strong></p><p>支持不同编码(orc/parquet), 支持不同文件系统(local/hdfs/s3)。这个都差不多</p><p><strong>序列化器</strong></p><p>支持PrestoPage格式，支持Spark的UnsafeRow格式</p><p><strong>资源管理</strong></p><p>包含内存池，Cache, pipeline执行，线程池，spill等</p><p>spill支持：内存紧张时spill, 内存宽裕时恢复执行。CH中join/sort/aggregate都支持spill功能。</p><p>本地缓存：通过将远程io stall隐藏在cpu计算中，来提升查询性能。这里有个小优化，如果io range之间距离比较近，则合并读取，以减少远程io请求次数。CH有类似实现(<a href="https://link.zhihu.com/?target=https%3A//github.com/ClickHouse/ClickHouse/pull/70534">https://github.com/ClickHouse/ClickHouse/pull/70534</a>)。</p><p><strong>性能测试</strong></p><p>主要比较prestissimo(底层适用velox执行计算)和presto.</p><p><strong>TPC-H数据集</strong></p><p>Q1和Q6是cpu bound查询，所以prestissimo的加速效果更好。Q13和Q19的瓶颈在shuffle, 因此效果有限。</p><p><img src=https://picx.zhimg.com/v2-90d5b3175d65c1a864e60091afa22235_1440w.jpg alt></p><p><strong>生产数据集</strong></p><p><img src=https://pic3.zhimg.com/v2-5fcd65b0c6e5e19a3bdd034b866861da_1440w.jpg alt></p></div><div class=post-copyright><p class=copyright-item><span class=item-title>文章作者</span>
<span class=item-content>后端侠</span></p><p class=copyright-item><span class=item-title>上次更新</span>
<span class=item-content>2025-05-20</span></p></div><footer class=post-footer><div class=post-tags><a href=/tags/paper/>paper</a></div><nav class=post-nav><a class=prev href=/post/the-composable-data-management-system-manifesto%E7%AC%94%E8%AE%B0/><i class="iconfont icon-left"></i><span class="prev-text nav-default">《The Composable Data Management System Manifesto》笔记</span>
<span class="prev-text nav-mobile">上一篇</span></a>
<a class=next href=/post/an-empirical-evaluation-of-columnar-storage-formats%E7%AC%94%E8%AE%B0/><span class="next-text nav-default">《An Empirical Evaluation of Columnar Storage Formats》笔记</span>
<span class="next-text nav-mobile">下一篇</span>
<i class="iconfont icon-right"></i></a></nav></footer></article></div><script src=https://utteranc.es/client.js repo=BackendHouse/hugo-comment issue-term=pathname theme=github-light crossorigin=anonymous async></script><noscript>Please enable JavaScript to view the <a href=https://github.com/utterance>comments powered by utterances.</a></noscript></div></main><footer id=footer class=footer><div class=social-links><a href=http://github.com/%e5%90%8e%e7%ab%af%e4%be%a0 class="iconfont icon-github" title=github></a><a href=https://backendhouse.github.io/index.xml type=application/rss+xml class="iconfont icon-rss" title=rss></a></div><div class=copyright><span class=power-by>由 <a class=hexo-link href=https://gohugo.io>Hugo</a> 强力驱动</span>
<span class=division>|</span>
<span class=theme-info>主题 -
<a class=theme-link href=https://github.com/olOwOlo/hugo-theme-even>Even</a></span>
<span class=copyright-year>&copy;
2020 -
2025<span class=heart><i class="iconfont icon-heart"></i></span><span>后端侠</span></span></div></footer><div class=back-to-top id=back-to-top><i class="iconfont icon-up"></i></div></div><script src="/lib/highlight/highlight.pack.js?v=20171001"></script><script src=https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin=anonymous></script><script type=text/javascript src=/js/main.min.c12618f9a600c40bd024996677e951e64d3487006775aeb22e200c990006c5c7.js></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-SYKLLYTW9K"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments);}
gtag('js',new Date());gtag('config','G-SYKLLYTW9K');</script></body></html>